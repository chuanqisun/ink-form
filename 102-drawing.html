<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL2 Particle System with Stroke Canvas</title>
  </head>
  <body>
    <canvas id="particleCanvas" width="800" height="800" style="border: 4px double #000"></canvas>
    <br />
    <canvas id="strokeCanvas" width="800" height="800" style="border: 4px double #000"></canvas>
    <br />
    <button id="clearBtn">Clear</button>
    <div>Particles: <span id="count">0</span></div>

    <script>
      class StrokeCanvas {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.isDrawing = false;
          this.ctx.lineWidth = 2;
          this.ctx.lineCap = "round";
          this.ctx.strokeStyle = "#000";
        }

        startDrawing(x, y) {
          this.isDrawing = true;
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
        }

        draw(x, y) {
          if (!this.isDrawing) return;
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
        }

        stopDrawing() {
          this.isDrawing = false;
        }

        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
      }

      class ParticleSystem {
        constructor(particleCanvasId, strokeCanvasId) {
          this.canvas = document.getElementById(particleCanvasId);
          this.gl = this.canvas.getContext("webgl2");
          this.strokeCanvas = new StrokeCanvas(strokeCanvasId);
          this.maxParticles = 100000;
          this.particleCount = 0;
          this.isPointerDown = false;
          this.lastAddTime = 0;
          this.pointerPos = { x: 0, y: 0 };

          this.initWebGL();
          this.initBuffers();
          this.initEventListeners();
          this.animate();
        }

        initWebGL() {
          const gl = this.gl;

          const updateVertexShader = `#version 300 es
                    in vec2 a_position;
                    in vec2 a_velocity;
                    out vec2 v_position;
                    out vec2 v_velocity;
                    uniform float u_deltaTime;
                    uniform vec2 u_resolution;
                    uniform float u_randomSeed;
                    
                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233)) + u_randomSeed) * 43758.5453123);
                    }
                    
                    void main() {
                        vec2 newVel = a_velocity;
                        float rand1 = random(a_position.xy + vec2(0.1, 0.2)) - 0.5;
                        float rand2 = random(a_position.xy + vec2(0.3, 0.4)) - 0.5;
                        newVel += vec2(rand1, rand2) * 0.5;
                        newVel *= 0.99;
                        
                        vec2 newPos = a_position + newVel * u_deltaTime;
                        
                        if(newPos.x < 0.0 || newPos.x > u_resolution.x) {
                            newVel.x *= -0.8;
                            newPos.x = clamp(newPos.x, 0.0, u_resolution.x);
                        }
                        if(newPos.y < 0.0 || newPos.y > u_resolution.y) {
                            newVel.y *= -0.8;
                            newPos.y = clamp(newPos.y, 0.0, u_resolution.y);
                        }
                        
                        v_position = newPos;
                        v_velocity = newVel;
                    }
                `;

          const updateFragmentShader = `#version 300 es
                    precision highp float;
                    void main() {}
                `;

          const renderVertexShader = `#version 300 es
                    in vec2 a_position;
                    uniform vec2 u_resolution;
                    
                    void main() {
                        vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
                        gl_Position = vec4(clipSpace.x, -clipSpace.y, 0.0, 1.0);
                        gl_PointSize = 1.0;
                    }
                `;

          const renderFragmentShader = `#version 300 es
                    precision highp float;
                    out vec4 outColor;
                    
                    void main() {
                        outColor = vec4(0.0, 0.0, 0.0, 1.0);
                    }
                `;

          this.updateProgram = this.createProgram(updateVertexShader, updateFragmentShader, ["v_position", "v_velocity"]);
          this.renderProgram = this.createProgram(renderVertexShader, renderFragmentShader, null);
        }

        createProgram(vsSource, fsSource, varyings) {
          const gl = this.gl;
          const vs = this.compileShader(gl.VERTEX_SHADER, vsSource);
          const fs = this.compileShader(gl.FRAGMENT_SHADER, fsSource);
          const program = gl.createProgram();
          gl.attachShader(program, vs);
          gl.attachShader(program, fs);

          if (varyings) {
            gl.transformFeedbackVaryings(program, varyings, gl.SEPARATE_ATTRIBS);
          }

          gl.linkProgram(program);
          if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
          }
          return program;
        }

        compileShader(type, source) {
          const gl = this.gl;
          const shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
          }
          return shader;
        }

        initBuffers() {
          const gl = this.gl;

          this.positionBuffers = [gl.createBuffer(), gl.createBuffer()];
          this.velocityBuffers = [gl.createBuffer(), gl.createBuffer()];

          const initialPositions = new Float32Array(this.maxParticles * 2);
          const initialVelocities = new Float32Array(this.maxParticles * 2);

          gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffers[0]);
          gl.bufferData(gl.ARRAY_BUFFER, initialPositions, gl.DYNAMIC_COPY);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffers[1]);
          gl.bufferData(gl.ARRAY_BUFFER, initialPositions, gl.DYNAMIC_COPY);

          gl.bindBuffer(gl.ARRAY_BUFFER, this.velocityBuffers[0]);
          gl.bufferData(gl.ARRAY_BUFFER, initialVelocities, gl.DYNAMIC_COPY);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.velocityBuffers[1]);
          gl.bufferData(gl.ARRAY_BUFFER, initialVelocities, gl.DYNAMIC_COPY);

          this.updateVAOs = [gl.createVertexArray(), gl.createVertexArray()];
          this.renderVAOs = [gl.createVertexArray(), gl.createVertexArray()];

          for (let i = 0; i < 2; i++) {
            gl.bindVertexArray(this.updateVAOs[i]);

            const posLoc = gl.getAttribLocation(this.updateProgram, "a_position");
            gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffers[i]);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            const velLoc = gl.getAttribLocation(this.updateProgram, "a_velocity");
            gl.bindBuffer(gl.ARRAY_BUFFER, this.velocityBuffers[i]);
            gl.enableVertexAttribArray(velLoc);
            gl.vertexAttribPointer(velLoc, 2, gl.FLOAT, false, 0, 0);

            gl.bindVertexArray(this.renderVAOs[i]);
            const renderPosLoc = gl.getAttribLocation(this.renderProgram, "a_position");
            gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffers[i]);
            gl.enableVertexAttribArray(renderPosLoc);
            gl.vertexAttribPointer(renderPosLoc, 2, gl.FLOAT, false, 0, 0);
          }

          this.transformFeedbacks = [gl.createTransformFeedback(), gl.createTransformFeedback()];

          for (let i = 0; i < 2; i++) {
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.transformFeedbacks[i]);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.positionBuffers[(i + 1) % 2]);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, this.velocityBuffers[(i + 1) % 2]);
          }

          gl.bindVertexArray(null);
          gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

          this.currentBuffer = 0;
        }

        initEventListeners() {
          this.canvas.addEventListener("pointerdown", (e) => {
            this.isPointerDown = true;
            this.updatePointerPos(e);
            this.strokeCanvas.startDrawing(this.pointerPos.x, this.pointerPos.y);
          });

          this.canvas.addEventListener("pointermove", (e) => {
            this.updatePointerPos(e);
            if (this.isPointerDown) {
              this.strokeCanvas.draw(this.pointerPos.x, this.pointerPos.y);
            }
          });

          this.canvas.addEventListener("pointerup", () => {
            this.isPointerDown = false;
            this.strokeCanvas.stopDrawing();
          });

          this.canvas.addEventListener("pointerout", () => {
            this.isPointerDown = false;
            this.strokeCanvas.stopDrawing();
          });

          document.getElementById("clearBtn").addEventListener("click", () => this.clear());
        }

        updatePointerPos(e) {
          const rect = this.canvas.getBoundingClientRect();
          this.pointerPos.x = e.clientX - rect.left;
          this.pointerPos.y = e.clientY - rect.top;
        }

        addParticles(count) {
          if (this.particleCount >= this.maxParticles) return;

          const gl = this.gl;
          const toAdd = Math.min(count, this.maxParticles - this.particleCount);

          const positions = new Float32Array(toAdd * 2);
          const velocities = new Float32Array(toAdd * 2);

          for (let i = 0; i < toAdd; i++) {
            positions[i * 2] = this.pointerPos.x;
            positions[i * 2 + 1] = this.pointerPos.y;
            velocities[i * 2] = (Math.random() - 0.5) * 100;
            velocities[i * 2 + 1] = (Math.random() - 0.5) * 100;
          }

          gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffers[this.currentBuffer]);
          gl.bufferSubData(gl.ARRAY_BUFFER, this.particleCount * 8, positions);

          gl.bindBuffer(gl.ARRAY_BUFFER, this.velocityBuffers[this.currentBuffer]);
          gl.bufferSubData(gl.ARRAY_BUFFER, this.particleCount * 8, velocities);

          this.particleCount += toAdd;
          document.getElementById("count").textContent = this.particleCount;
        }

        update(deltaTime) {
          if (this.particleCount === 0) return;

          const gl = this.gl;
          gl.useProgram(this.updateProgram);

          gl.uniform1f(gl.getUniformLocation(this.updateProgram, "u_deltaTime"), deltaTime);
          gl.uniform2f(gl.getUniformLocation(this.updateProgram, "u_resolution"), this.canvas.width, this.canvas.height);
          gl.uniform1f(gl.getUniformLocation(this.updateProgram, "u_randomSeed"), Math.random() * 1000);

          gl.bindVertexArray(this.updateVAOs[this.currentBuffer]);
          gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.transformFeedbacks[this.currentBuffer]);

          gl.enable(gl.RASTERIZER_DISCARD);
          gl.beginTransformFeedback(gl.POINTS);
          gl.drawArrays(gl.POINTS, 0, this.particleCount);
          gl.endTransformFeedback();
          gl.disable(gl.RASTERIZER_DISCARD);

          gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

          this.currentBuffer = (this.currentBuffer + 1) % 2;
        }

        render() {
          if (this.particleCount === 0) return;

          const gl = this.gl;
          gl.useProgram(this.renderProgram);
          gl.uniform2f(gl.getUniformLocation(this.renderProgram, "u_resolution"), this.canvas.width, this.canvas.height);

          gl.bindVertexArray(this.renderVAOs[this.currentBuffer]);
          gl.drawArrays(gl.POINTS, 0, this.particleCount);
        }

        clear() {
          this.particleCount = 0;
          document.getElementById("count").textContent = 0;
          const gl = this.gl;
          gl.clearColor(1, 1, 1, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);
          this.strokeCanvas.clear();
        }

        animate(currentTime = 0) {
          const deltaTime = Math.min((currentTime - (this.lastTime || currentTime)) / 1000, 0.1);
          this.lastTime = currentTime;

          if (this.isPointerDown) {
            const now = performance.now();
            if (now - this.lastAddTime > 10) {
              this.addParticles(10);
              this.lastAddTime = now;
            }
          }

          this.update(deltaTime);

          const gl = this.gl;
          gl.clearColor(1, 1, 1, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);

          this.render();

          requestAnimationFrame((t) => this.animate(t));
        }
      }

      const particleSystem = new ParticleSystem("particleCanvas", "strokeCanvas");
    </script>
  </body>
</html>
