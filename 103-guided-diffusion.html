<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL2 Particle System with Stroke Canvas</title>
  </head>
  <body>
    <canvas id="particleCanvas" width="300" height="600" style="border: 4px double #000"></canvas>
    <canvas id="strokeCanvas" width="300" height="600" style="border: 4px double #000"></canvas>
    <br />
    <button commandfor="connection-dialog" command="show-modal">Setup</button>
    <button id="clearBtn">Clear</button>
    <div>Particles: <span id="count">0</span></div>
    <div>FPS: <span id="fps">0</span></div>

    <dialog class="connection-form" id="connection-dialog">
      <div class="connections-dialog-body">
        <form method="dialog" id="ai-connection-form">
          <h2>Google AI Studio Connection</h2>
          <label for="api-key-input">API Key:</label>
          <input type="password" id="api-key-input" placeholder="Enter your Google AI Studio API key" />
          <button type="button" id="connect-btn">Connect</button>
          <button type="button" id="disconnect-btn" style="display: none">Disconnect</button>
          <button type="submit">Close</button>
          <div id="connection-status"></div>
        </form>
      </div>
    </dialog>

    <script>
      class PerformanceMonitor {
        constructor() {
          this.frameTimes = [];
          this.lastTime = 0;
        }

        update(currentTime) {
          if (this.lastTime > 0) {
            const delta = currentTime - this.lastTime;
            this.frameTimes.push(delta);
            if (this.frameTimes.length > 10) {
              this.frameTimes.shift();
            }
          }
          this.lastTime = currentTime;
          return this.getFPS();
        }

        getFPS() {
          if (this.frameTimes.length === 0) return 0;
          const avg = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
          return Math.round(1000 / avg);
        }
      }

      class AIConnection {
        constructor() {
          this.apiKey = null;
          this.isConnected = false;
          this.initEventListeners();
          this.loadApiKey();
        }

        initEventListeners() {
          const connectBtn = document.getElementById("connect-btn");
          const disconnectBtn = document.getElementById("disconnect-btn");
          const apiKeyInput = document.getElementById("api-key-input");

          connectBtn.addEventListener("click", () => this.connect());
          disconnectBtn.addEventListener("click", () => this.disconnect());

          // Allow Enter key to connect
          apiKeyInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              this.connect();
            }
          });
        }

        loadApiKey() {
          const stored = localStorage.getItem("google_ai_api_key");
          if (stored) {
            this.apiKey = stored;
            this.setConnected(true);
          }
        }

        connect() {
          const apiKeyInput = document.getElementById("api-key-input");
          const apiKey = apiKeyInput.value.trim();

          if (!apiKey) {
            this.updateStatus("Please enter an API key", "error");
            return;
          }

          // Store the API key
          this.apiKey = apiKey;
          localStorage.setItem("google_ai_api_key", apiKey);
          this.setConnected(true);
          this.updateStatus("Connected successfully!", "success");
        }

        disconnect() {
          this.apiKey = null;
          localStorage.removeItem("google_ai_api_key");
          this.setConnected(false);
          document.getElementById("api-key-input").value = "";
          this.updateStatus("Disconnected", "info");
        }

        setConnected(connected) {
          this.isConnected = connected;
          const connectBtn = document.getElementById("connect-btn");
          const disconnectBtn = document.getElementById("disconnect-btn");
          const apiKeyInput = document.getElementById("api-key-input");

          if (connected) {
            connectBtn.style.display = "none";
            disconnectBtn.style.display = "inline-block";
            apiKeyInput.disabled = true;
            apiKeyInput.value = this.apiKey;
          } else {
            connectBtn.style.display = "inline-block";
            disconnectBtn.style.display = "none";
            apiKeyInput.disabled = false;
            apiKeyInput.value = "";
          }
        }

        updateStatus(message, type = "info") {
          const statusDiv = document.getElementById("connection-status");
          statusDiv.textContent = message;
          statusDiv.style.color = type === "error" ? "red" : type === "success" ? "green" : "blue";
        }

        getApiKey() {
          return this.apiKey;
        }

        isAPIConnected() {
          return this.isConnected;
        }
      }

      class StrokeCanvas {
        constructor(canvasId, strokeWidth = 2) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.isDrawing = false;
          this.ctx.lineWidth = strokeWidth;
          this.ctx.lineCap = "round";
          this.ctx.strokeStyle = "#000";
        }

        startDrawing(x, y) {
          this.isDrawing = true;
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
        }

        draw(x, y) {
          if (!this.isDrawing) return;
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
        }

        stopDrawing() {
          this.isDrawing = false;
        }

        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }

        getImageData() {
          return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        }
      }

      class ParticleSystem {
        constructor(particleCanvasId, strokeCanvasId) {
          this.canvas = document.getElementById(particleCanvasId);
          this.ctx = this.canvas.getContext("2d");

          // Debug stroke canvas (persistent)
          this.strokeCanvas = new StrokeCanvas(strokeCanvasId, 2);

          // Temporary canvas for capturing current stroke segment
          this.tempCanvas = document.createElement("canvas");
          this.tempCanvas.width = this.canvas.width;
          this.tempCanvas.height = this.canvas.height;
          this.tempCtx = this.tempCanvas.getContext("2d");
          this.tempCtx.lineWidth = 1; // Small width to limit particle count
          this.tempCtx.lineCap = "round";
          this.tempCtx.strokeStyle = "#000";

          this.maxParticles = 100000;
          this.particles = [];
          this.isPointerDown = false;
          this.lastAddTime = 0;
          this.pointerPos = { x: 0, y: 0 };
          this.perfMonitor = new PerformanceMonitor();
          this.isDrawing = false;

          this.initEventListeners();
          this.animate();
        }

        initEventListeners() {
          this.canvas.addEventListener("pointerdown", (e) => {
            this.isPointerDown = true;
            this.isDrawing = true;
            this.updatePointerPos(e);

            // Start drawing on both canvases
            this.strokeCanvas.startDrawing(this.pointerPos.x, this.pointerPos.y);

            // Start drawing on particle canvas (visible)
            this.ctx.lineWidth = 1;
            this.ctx.lineCap = "round";
            this.ctx.strokeStyle = "#000";
            this.ctx.beginPath();
            this.ctx.moveTo(this.pointerPos.x, this.pointerPos.y);

            // Start drawing on temp canvas (for particle conversion)
            this.tempCtx.clearRect(0, 0, this.tempCanvas.width, this.tempCanvas.height);
            this.tempCtx.beginPath();
            this.tempCtx.moveTo(this.pointerPos.x, this.pointerPos.y);
          });

          this.canvas.addEventListener("pointermove", (e) => {
            this.updatePointerPos(e);
            if (this.isPointerDown && this.isDrawing) {
              // Draw on debug canvas
              this.strokeCanvas.draw(this.pointerPos.x, this.pointerPos.y);

              // Draw on particle canvas (visible)
              this.ctx.lineTo(this.pointerPos.x, this.pointerPos.y);
              this.ctx.stroke();

              // Draw on temp canvas (for particle conversion)
              this.tempCtx.lineTo(this.pointerPos.x, this.pointerPos.y);
              this.tempCtx.stroke();
            }
          });

          this.canvas.addEventListener("pointerup", () => {
            if (this.isDrawing) {
              this.convertStrokeToParticles();
            }
            this.isPointerDown = false;
            this.isDrawing = false;
            this.strokeCanvas.stopDrawing();
          });

          this.canvas.addEventListener("pointerout", () => {
            if (this.isDrawing) {
              this.convertStrokeToParticles();
            }
            this.isPointerDown = false;
            this.isDrawing = false;
            this.strokeCanvas.stopDrawing();
          });

          document.getElementById("clearBtn").addEventListener("click", () => this.clear());
        }

        updatePointerPos(e) {
          const rect = this.canvas.getBoundingClientRect();
          this.pointerPos.x = e.clientX - rect.left;
          this.pointerPos.y = e.clientY - rect.top;
        }

        convertStrokeToParticles() {
          // Get the image data from the temporary canvas
          const imageData = this.tempCtx.getImageData(0, 0, this.tempCanvas.width, this.tempCanvas.height);
          const data = imageData.data;

          let particlesAdded = 0;
          const maxParticlesToAdd = this.maxParticles - this.particles.length;

          // Scan the entire canvas and create particles at non-transparent pixels
          for (let y = 0; y < imageData.height && particlesAdded < maxParticlesToAdd; y++) {
            for (let x = 0; x < imageData.width && particlesAdded < maxParticlesToAdd; x++) {
              const index = (y * imageData.width + x) * 4;
              const alpha = data[index + 3];

              // If there's a stroke at this position, create a particle
              if (alpha > 0) {
                this.particles.push({
                  x: x,
                  y: y,
                  vx: (Math.random() - 0.5) * 0.5,
                  vy: (Math.random() - 0.5) * 0.5,
                });
                particlesAdded++;
              }
            }
          }

          document.getElementById("count").textContent = this.particles.length;

          // Clear the temporary canvas for the next stroke
          this.tempCtx.clearRect(0, 0, this.tempCanvas.width, this.tempCanvas.height);
        }

        update(deltaTime) {
          // Get stroke bitmap data for force field
          const strokeImageData = this.strokeCanvas.ctx.getImageData(0, 0, this.strokeCanvas.canvas.width, this.strokeCanvas.canvas.height);
          const strokeData = strokeImageData.data;

          for (const p of this.particles) {
            // Apply force field from stroke bitmap
            this.applyForceField(p, strokeData, strokeImageData.width, strokeImageData.height);

            // Add some randomness
            p.vx += (Math.random() - 0.5) * 0.5;
            p.vy += (Math.random() - 0.5) * 0.5;

            p.vx *= 0.99;
            p.vy *= 0.99;

            p.x += p.vx;
            p.y += p.vy;

            if (p.x < 0 || p.x > this.canvas.width) {
              p.vx *= -0.8;
              p.x = Math.max(0, Math.min(this.canvas.width, p.x));
            }
            if (p.y < 0 || p.y > this.canvas.height) {
              p.vy *= -0.8;
              p.y = Math.max(0, Math.min(this.canvas.height, p.y));
            }
          }
        }

        applyForceField(particle, strokeData, width, height) {
          const searchRadius = 50; // Pixels to search around particle
          const attractionStrength = 0.5; // Force magnitude

          let closestDist = Infinity;
          let closestX = 0;
          let closestY = 0;

          // Search in a square around the particle
          const startX = Math.max(0, Math.floor(particle.x - searchRadius));
          const endX = Math.min(width - 1, Math.ceil(particle.x + searchRadius));
          const startY = Math.max(0, Math.floor(particle.y - searchRadius));
          const endY = Math.min(height - 1, Math.ceil(particle.y + searchRadius));

          // Find closest stroke pixel
          for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
              const index = (y * width + x) * 4;
              const alpha = strokeData[index + 3]; // Check alpha channel

              // If there's a stroke at this position
              if (alpha > 0) {
                const dx = x - particle.x;
                const dy = y - particle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < closestDist && dist > 0) {
                  closestDist = dist;
                  closestX = x;
                  closestY = y;
                }
              }
            }
          }

          // Apply attraction force towards closest stroke pixel
          if (closestDist < Infinity) {
            const dx = closestX - particle.x;
            const dy = closestY - particle.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0) {
              // Normalize direction and apply force
              const force = attractionStrength / (1 + dist * 0.1); // Force decreases with distance
              particle.vx += (dx / dist) * force;
              particle.vy += (dy / dist) * force;
            }
          }
        }

        render() {
          this.ctx.fillStyle = "black";
          for (const p of this.particles) {
            this.ctx.fillRect(p.x, p.y, 1, 1);
          }

          // Draw temporary canvas content (current stroke being drawn)
          this.ctx.drawImage(this.tempCanvas, 0, 0);
        }

        clear() {
          this.particles = [];
          document.getElementById("count").textContent = 0;
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.strokeCanvas.clear();
        }

        animate(currentTime = 0) {
          const deltaTime = Math.min((currentTime - (this.lastTime || currentTime)) / 1000, 0.1);
          this.lastTime = currentTime;

          const fps = this.perfMonitor.update(currentTime);
          document.getElementById("fps").textContent = fps;

          // Always update particles
          this.update(deltaTime);

          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Always render particles
          this.render();

          requestAnimationFrame((t) => this.animate(t));
        }
      }

      const aiConnection = new AIConnection();
      const particleSystem = new ParticleSystem("particleCanvas", "strokeCanvas");
    </script>
  </body>
</html>
