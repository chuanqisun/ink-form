<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Disintegrating Square - WebGL</title>
  </head>
  <body>
    <canvas id="canvas" width="800" height="800"></canvas>
    <button onclick="app.start()">Play</button>
    <div><span id="fps"></span> fps</div>

    <script>
      // Performance Monitor - standalone FPS tracking
      class PerformanceMonitor {
        constructor(options = {}) {
          this.windowSize = options.windowSize || 60; // Number of frames to average
          this.frameIntervals = [];
          this.lastFrameTime = performance.now();
          this.onFpsUpdate = options.onFpsUpdate || (() => {});
        }

        tick() {
          const currentTime = performance.now();
          const frameInterval = currentTime - this.lastFrameTime;
          this.lastFrameTime = currentTime;

          this.frameIntervals.push(frameInterval);
          if (this.frameIntervals.length > this.windowSize) {
            this.frameIntervals.shift();
          }

          const fps = this.calculateFps();
          this.onFpsUpdate(fps);
          return fps;
        }

        calculateFps() {
          if (this.frameIntervals.length === 0) return 0;
          const avgInterval = this.frameIntervals.reduce((a, b) => a + b, 0) / this.frameIntervals.length;
          return Math.round(1000 / avgInterval);
        }

        reset() {
          this.frameIntervals = [];
          this.lastFrameTime = performance.now();
        }
      }

      // GPU Particle System - physics simulation runs on GPU using Transform Feedback
      class GPUParticleSystem {
        constructor(canvas) {
          this.canvas = canvas;
          this.gl = canvas.getContext("webgl2");

          if (!this.gl) {
            throw new Error("WebGL2 not supported");
          }

          this.width = canvas.width;
          this.height = canvas.height;
          this.particleCount = 0;

          this.initUpdateProgram();
          this.initRenderProgram();
          this.initBuffers();
        }

        initUpdateProgram() {
          const gl = this.gl;

          // Vertex shader for physics update (runs on GPU)
          const updateVertexShader = `#version 300 es
                    in vec2 a_position;
                    in vec2 a_velocity;
                    
                    uniform vec2 u_bounds;
                    
                    out vec2 v_position;
                    out vec2 v_velocity;
                    
                    void main() {
                        vec2 newPos = a_position + a_velocity;
                        vec2 newVel = a_velocity;
                        
                        // Bounce off boundaries
                        if (newPos.x < 0.0 || newPos.x >= u_bounds.x) {
                            newVel.x *= -1.0;
                            newPos.x = clamp(newPos.x, 0.0, u_bounds.x - 1.0);
                        }
                        if (newPos.y < 0.0 || newPos.y >= u_bounds.y) {
                            newVel.y *= -1.0;
                            newPos.y = clamp(newPos.y, 0.0, u_bounds.y - 1.0);
                        }
                        
                        v_position = newPos;
                        v_velocity = newVel;
                    }
                `;

          // Fragment shader for update (not used but required)
          const updateFragmentShader = `#version 300 es
                    precision mediump float;
                    out vec4 outColor;
                    void main() {
                        outColor = vec4(1.0);
                    }
                `;

          const vs = this.compileShader(gl.VERTEX_SHADER, updateVertexShader);
          const fs = this.compileShader(gl.FRAGMENT_SHADER, updateFragmentShader);

          this.updateProgram = gl.createProgram();
          gl.attachShader(this.updateProgram, vs);
          gl.attachShader(this.updateProgram, fs);

          // Specify transform feedback varyings BEFORE linking
          gl.transformFeedbackVaryings(this.updateProgram, ["v_position", "v_velocity"], gl.INTERLEAVED_ATTRIBS);

          gl.linkProgram(this.updateProgram);

          if (!gl.getProgramParameter(this.updateProgram, gl.LINK_STATUS)) {
            throw new Error("Update program link failed: " + gl.getProgramInfoLog(this.updateProgram));
          }

          // Get locations
          this.updatePositionLoc = gl.getAttribLocation(this.updateProgram, "a_position");
          this.updateVelocityLoc = gl.getAttribLocation(this.updateProgram, "a_velocity");
          this.updateBoundsLoc = gl.getUniformLocation(this.updateProgram, "u_bounds");
        }

        initRenderProgram() {
          const gl = this.gl;

          // Vertex shader for rendering
          const renderVertexShader = `#version 300 es
                    in vec2 a_position;
                    uniform vec2 u_resolution;
                    
                    void main() {
                        vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
                        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
                        gl_PointSize = 1.0;
                    }
                `;

          // Fragment shader for rendering
          const renderFragmentShader = `#version 300 es
                    precision mediump float;
                    uniform vec4 u_color;
                    out vec4 outColor;
                    
                    void main() {
                        outColor = u_color;
                    }
                `;

          const vs = this.compileShader(gl.VERTEX_SHADER, renderVertexShader);
          const fs = this.compileShader(gl.FRAGMENT_SHADER, renderFragmentShader);

          this.renderProgram = gl.createProgram();
          gl.attachShader(this.renderProgram, vs);
          gl.attachShader(this.renderProgram, fs);
          gl.linkProgram(this.renderProgram);

          if (!gl.getProgramParameter(this.renderProgram, gl.LINK_STATUS)) {
            throw new Error("Render program link failed: " + gl.getProgramInfoLog(this.renderProgram));
          }

          // Get locations
          this.renderPositionLoc = gl.getAttribLocation(this.renderProgram, "a_position");
          this.renderResolutionLoc = gl.getUniformLocation(this.renderProgram, "u_resolution");
          this.renderColorLoc = gl.getUniformLocation(this.renderProgram, "u_color");
        }

        compileShader(type, source) {
          const gl = this.gl;
          const shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);

          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const info = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error("Shader compile failed: " + info);
          }

          return shader;
        }

        initBuffers() {
          const gl = this.gl;

          // Create two buffers for ping-pong
          this.buffers = [
            {
              buffer: gl.createBuffer(),
              vao: gl.createVertexArray(),
              tf: gl.createTransformFeedback(),
            },
            {
              buffer: gl.createBuffer(),
              vao: gl.createVertexArray(),
              tf: gl.createTransformFeedback(),
            },
          ];

          this.currentBuffer = 0;

          // Setup square rendering buffer
          this.squareBuffer = gl.createBuffer();
          this.squareVAO = gl.createVertexArray();
        }

        createSquare(x, y, size) {
          const gl = this.gl;
          const particles = [];

          // Generate particle data
          for (let py = y; py < y + size; py++) {
            for (let px = x; px < x + size; px++) {
              particles.push(
                px, // position x
                py, // position y
                (Math.random() - 0.5) * 2, // velocity x
                (Math.random() - 0.5) * 2 // velocity y
              );
            }
          }

          this.particleCount = size * size;
          const data = new Float32Array(particles);

          // Initialize both buffers with the same data
          for (let i = 0; i < 2; i++) {
            const buf = this.buffers[i];

            // Setup buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buf.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_COPY);

            // Setup VAO for update program
            gl.bindVertexArray(buf.vao);
            gl.bindBuffer(gl.ARRAY_BUFFER, buf.buffer);
            gl.enableVertexAttribArray(this.updatePositionLoc);
            gl.vertexAttribPointer(this.updatePositionLoc, 2, gl.FLOAT, false, 16, 0);
            gl.enableVertexAttribArray(this.updateVelocityLoc);
            gl.vertexAttribPointer(this.updateVelocityLoc, 2, gl.FLOAT, false, 16, 8);

            // Setup transform feedback
            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, buf.tf);
            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, buf.buffer);
          }

          gl.bindVertexArray(null);
          gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
        }

        update() {
          const gl = this.gl;

          const sourceBuffer = this.buffers[this.currentBuffer];
          const targetBuffer = this.buffers[1 - this.currentBuffer];

          // Use update program
          gl.useProgram(this.updateProgram);
          gl.uniform2f(this.updateBoundsLoc, this.width, this.height);

          // Bind source VAO (input)
          gl.bindVertexArray(sourceBuffer.vao);

          // Bind target transform feedback (output)
          gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, targetBuffer.tf);

          // Disable rasterization (we don't need to render during update)
          gl.enable(gl.RASTERIZER_DISCARD);

          // Run the update shader with transform feedback
          gl.beginTransformFeedback(gl.POINTS);
          gl.drawArrays(gl.POINTS, 0, this.particleCount);
          gl.endTransformFeedback();

          gl.disable(gl.RASTERIZER_DISCARD);

          // Unbind
          gl.bindVertexArray(null);
          gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

          // Swap buffers
          this.currentBuffer = 1 - this.currentBuffer;
        }

        render(color = { r: 0, g: 0, b: 0, a: 1 }) {
          const gl = this.gl;

          // Clear screen
          gl.clearColor(1.0, 1.0, 1.0, 1.0);
          gl.clear(gl.COLOR_BUFFER_BIT);

          if (this.particleCount === 0) return;

          // Use render program
          gl.useProgram(this.renderProgram);
          gl.uniform2f(this.renderResolutionLoc, this.width, this.height);
          gl.uniform4f(this.renderColorLoc, color.r, color.g, color.b, color.a);

          // Bind current buffer
          const currentBuf = this.buffers[this.currentBuffer];
          gl.bindBuffer(gl.ARRAY_BUFFER, currentBuf.buffer);

          // Setup position attribute for rendering (only position, skip velocity)
          gl.enableVertexAttribArray(this.renderPositionLoc);
          gl.vertexAttribPointer(this.renderPositionLoc, 2, gl.FLOAT, false, 16, 0);

          // Draw particles
          gl.drawArrays(gl.POINTS, 0, this.particleCount);

          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }

        drawSquare(x, y, size, color = { r: 0, g: 0, b: 0, a: 1 }) {
          const gl = this.gl;

          // Create vertices for the square (two triangles)
          const x1 = x;
          const y1 = y;
          const x2 = x + size;
          const y2 = y + size;

          const positions = new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]);

          gl.bindBuffer(gl.ARRAY_BUFFER, this.squareBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

          gl.useProgram(this.renderProgram);
          gl.uniform2f(this.renderResolutionLoc, this.width, this.height);
          gl.uniform4f(this.renderColorLoc, color.r, color.g, color.b, color.a);

          gl.enableVertexAttribArray(this.renderPositionLoc);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.squareBuffer);
          gl.vertexAttribPointer(this.renderPositionLoc, 2, gl.FLOAT, false, 0, 0);

          gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        clear() {
          const gl = this.gl;
          gl.clearColor(1.0, 1.0, 1.0, 1.0);
          gl.clear(gl.COLOR_BUFFER_BIT);
          this.particleCount = 0;
        }
      }

      // Application
      class Application {
        constructor(canvas, button, fpsDisplay) {
          this.canvas = canvas;
          this.squareSize = 400;
          this.squareX = canvas.width / 2 - this.squareSize / 2;
          this.squareY = canvas.height / 2 - this.squareSize / 2;
          this.button = button;

          try {
            this.gpuSystem = new GPUParticleSystem(canvas);
          } catch (e) {
            alert("WebGL2 not supported: " + e.message);
            throw e;
          }

          this.animating = false;
          this.animationId = null;

          // Performance monitoring with callback
          this.performanceMonitor = new PerformanceMonitor({
            windowSize: 60,
            onFpsUpdate: (fps) => {
              fpsDisplay.textContent = fps;
            },
          });

          this.reset();
        }

        reset() {
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }

          this.animating = false;
          this.button.disabled = false;

          // Draw initial state
          this.gpuSystem.clear();
          this.gpuSystem.drawSquare(this.squareX, this.squareY, this.squareSize, { r: 0, g: 0, b: 0, a: 1 });
        }

        start() {
          if (this.animating) return;

          this.animating = true;
          this.button.disabled = true;

          this.gpuSystem.createSquare(this.squareX, this.squareY, this.squareSize);
          this.animate();
        }

        animate() {
          // Both update and render now run on GPU!
          this.gpuSystem.update();
          this.gpuSystem.render({ r: 0, g: 0, b: 0, a: 1 });

          // Track performance
          this.performanceMonitor.tick();

          if (this.animating) {
            this.animationId = requestAnimationFrame(() => this.animate());
          }
        }
      }

      // Initialize application
      const canvas = document.getElementById("canvas");
      const button = document.querySelector("button");
      const fpsDisplay = document.getElementById("fps");
      const app = new Application(canvas, button, fpsDisplay);
    </script>
  </body>
</html>
