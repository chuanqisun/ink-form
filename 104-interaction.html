<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL2 Particle System with Stroke Canvas</title>
  </head>
  <body>
    <canvas id="particleCanvas" width="300" height="600" style="border: 4px double #000"></canvas>
    <canvas id="strokeCanvas" width="300" height="600" style="border: 4px double #000"></canvas>
    <br />
    <button id="clearBtn">Clear</button>
    <div>Particles: <span id="count">0</span></div>
    <div>FPS: <span id="fps">0</span></div>

    <script>
      class PerformanceMonitor {
        constructor() {
          this.frameTimes = [];
          this.lastTime = 0;
        }

        update(currentTime) {
          if (this.lastTime > 0) {
            const delta = currentTime - this.lastTime;
            this.frameTimes.push(delta);
            if (this.frameTimes.length > 10) {
              this.frameTimes.shift();
            }
          }
          this.lastTime = currentTime;
          return this.getFPS();
        }

        getFPS() {
          if (this.frameTimes.length === 0) return 0;
          const avg = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
          return Math.round(1000 / avg);
        }
      }

      class StrokeCanvas {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.isDrawing = false;
          this.ctx.lineWidth = 2;
          this.ctx.lineCap = "round";
          this.ctx.strokeStyle = "#000";
        }

        startDrawing(x, y) {
          this.isDrawing = true;
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
        }

        draw(x, y) {
          if (!this.isDrawing) return;
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
        }

        stopDrawing() {
          this.isDrawing = false;
        }

        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
      }

      class ParticleSystem {
        constructor(particleCanvasId, strokeCanvasId) {
          this.canvas = document.getElementById(particleCanvasId);
          this.ctx = this.canvas.getContext("2d");
          this.strokeCanvas = new StrokeCanvas(strokeCanvasId);
          this.maxParticles = 100000;
          this.particles = [];
          this.isPointerDown = false;
          this.lastAddTime = 0;
          this.pointerPos = { x: 0, y: 0 };
          this.perfMonitor = new PerformanceMonitor();

          this.initEventListeners();
          this.animate();
        }

        initEventListeners() {
          this.canvas.addEventListener("pointerdown", (e) => {
            this.isPointerDown = true;
            this.updatePointerPos(e);
            this.strokeCanvas.startDrawing(this.pointerPos.x, this.pointerPos.y);
          });

          this.canvas.addEventListener("pointermove", (e) => {
            this.updatePointerPos(e);
            if (this.isPointerDown) {
              this.strokeCanvas.draw(this.pointerPos.x, this.pointerPos.y);
            }
          });

          this.canvas.addEventListener("pointerup", () => {
            this.isPointerDown = false;
            this.strokeCanvas.stopDrawing();
          });

          this.canvas.addEventListener("pointerout", () => {
            this.isPointerDown = false;
            this.strokeCanvas.stopDrawing();
          });

          document.getElementById("clearBtn").addEventListener("click", () => this.clear());
        }

        updatePointerPos(e) {
          const rect = this.canvas.getBoundingClientRect();
          this.pointerPos.x = e.clientX - rect.left;
          this.pointerPos.y = e.clientY - rect.top;
        }

        addParticles(count) {
          if (this.particles.length >= this.maxParticles) return;

          const toAdd = Math.min(count, this.maxParticles - this.particles.length);

          for (let i = 0; i < toAdd; i++) {
            // Spawn near the pointer position (current stroke path)
            const spawnRadius = 30;
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spawnRadius;
            
            const x = this.pointerPos.x + Math.cos(angle) * distance;
            const y = this.pointerPos.y + Math.sin(angle) * distance;
            
            // Initial velocity pointing toward the pointer
            const vx = (Math.random() - 0.5) * 2;
            const vy = (Math.random() - 0.5) * 2;

            this.particles.push({
              x,
              y,
              vx,
              vy,
              settled: false,
            });
          }
          document.getElementById("count").textContent = this.particles.length;
        }

        update(deltaTime) {
          // Get stroke bitmap data for force field
          const strokeImageData = this.strokeCanvas.ctx.getImageData(0, 0, this.strokeCanvas.canvas.width, this.strokeCanvas.canvas.height);
          const strokeData = strokeImageData.data;

          for (const p of this.particles) {
            // Skip settled particles
            if (p.settled) continue;

            // Check if particle is on a stroke pixel
            const px = Math.floor(p.x);
            const py = Math.floor(p.y);
            if (px >= 0 && px < strokeImageData.width && py >= 0 && py < strokeImageData.height) {
              const index = (py * strokeImageData.width + px) * 4;
              const alpha = strokeData[index + 3];
              
              // If on stroke, settle the particle
              if (alpha > 0) {
                p.settled = true;
                p.vx = 0;
                p.vy = 0;
                continue;
              }
            }

            // Apply force field from stroke bitmap
            this.applyForceField(p, strokeData, strokeImageData.width, strokeImageData.height);

            // Add some randomness
            p.vx += (Math.random() - 0.5) * 0.5;
            p.vy += (Math.random() - 0.5) * 0.5;

            p.vx *= 0.99;
            p.vy *= 0.99;

            p.x += p.vx;
            p.y += p.vy;

            if (p.x < 0 || p.x > this.canvas.width) {
              p.vx *= -0.8;
              p.x = Math.max(0, Math.min(this.canvas.width, p.x));
            }
            if (p.y < 0 || p.y > this.canvas.height) {
              p.vy *= -0.8;
              p.y = Math.max(0, Math.min(this.canvas.height, p.y));
            }
          }
        }

        applyForceField(particle, strokeData, width, height) {
          const searchRadius = 50; // Pixels to search around particle
          const attractionStrength = 0.5; // Force magnitude

          let closestDist = Infinity;
          let closestX = 0;
          let closestY = 0;

          // Search in a square around the particle
          const startX = Math.max(0, Math.floor(particle.x - searchRadius));
          const endX = Math.min(width - 1, Math.ceil(particle.x + searchRadius));
          const startY = Math.max(0, Math.floor(particle.y - searchRadius));
          const endY = Math.min(height - 1, Math.ceil(particle.y + searchRadius));

          // Find closest stroke pixel
          for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
              const index = (y * width + x) * 4;
              const alpha = strokeData[index + 3]; // Check alpha channel

              // If there's a stroke at this position
              if (alpha > 0) {
                const dx = x - particle.x;
                const dy = y - particle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < closestDist && dist > 0) {
                  closestDist = dist;
                  closestX = x;
                  closestY = y;
                }
              }
            }
          }

          // Apply attraction force towards closest stroke pixel
          if (closestDist < Infinity) {
            const dx = closestX - particle.x;
            const dy = closestY - particle.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0) {
              // Normalize direction and apply force
              const force = attractionStrength / (1 + dist * 0.1); // Force decreases with distance
              particle.vx += (dx / dist) * force;
              particle.vy += (dy / dist) * force;
            }
          }
        }

        render() {
          this.ctx.fillStyle = "black";
          for (const p of this.particles) {
            this.ctx.fillRect(p.x, p.y, 1, 1);
          }
        }

        clear() {
          this.particles = [];
          document.getElementById("count").textContent = 0;
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.strokeCanvas.clear();
        }

        animate(currentTime = 0) {
          const deltaTime = Math.min((currentTime - (this.lastTime || currentTime)) / 1000, 0.1);
          this.lastTime = currentTime;

          const fps = this.perfMonitor.update(currentTime);
          document.getElementById("fps").textContent = fps;

          // Spawn particles only when pointer is down
          if (this.isPointerDown) {
            const now = performance.now();
            if (now - this.lastAddTime > 10) {
              this.addParticles(10);
              this.lastAddTime = now;
            }
          }

          this.update(deltaTime);

          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.render();

          requestAnimationFrame((t) => this.animate(t));
        }
      }

      const particleSystem = new ParticleSystem("particleCanvas", "strokeCanvas");
    </script>
  </body>
</html>
