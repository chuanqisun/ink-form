<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Disintegrating Square</title>
  </head>
  <body>
    <canvas id="canvas" width="1600" height="1600"></canvas>
    <button onclick="startAnimation()">Play</button>
    <div><span id="fps"></span> fps</div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;

      // Parameterize square dimension
      const squareDimension = 1000;
      const squareX = (width - squareDimension) / 2;
      const squareY = (height - squareDimension) / 2;

      let particles = [];
      let animating = false;
      let animationId = null;

      // FPS tracking using rolling average
      let frameIntervals = [];
      const maxIntervals = 60; // Keep last 60 frame intervals
      let lastFrameTime = performance.now();
      const fpsDisplay = document.getElementById("fps");

      // Initialize the square
      function reset() {
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }

        animating = false;
        particles = [];
        document.querySelector("button").disabled = false;

        // Clear canvas to white
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
          data[i + 0] = 255; // R
          data[i + 1] = 255; // G
          data[i + 2] = 255; // B
          data[i + 3] = 255; // A
        }

        // Draw 40x40 black square centered in canvas
        for (let y = squareY; y < squareY + squareDimension; y++) {
          for (let x = squareX; x < squareX + squareDimension; x++) {
            const index = (y * width + x) * 4;
            data[index + 0] = 0; // R
            data[index + 1] = 0; // G
            data[index + 2] = 0; // B
            data[index + 3] = 255; // A
          }
        }

        ctx.putImageData(imageData, 0, 0);
      }

      // Create particles from the square
      function createParticles() {
        particles = [];

        // Create a particle for each pixel in the square
        for (let y = squareY; y < squareY + squareDimension; y++) {
          for (let x = squareX; x < squareX + squareDimension; x++) {
            particles.push({
              x: x,
              y: y,
              vx: (Math.random() - 0.5) * 2, // Random velocity X
              vy: (Math.random() - 0.5) * 2, // Random velocity Y
            });
          }
        }
      }

      // Animation loop
      function animateFrame() {
        // Clear canvas to white
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;

        // Fill with white
        for (let i = 0; i < data.length; i += 4) {
          data[i + 0] = 255;
          data[i + 1] = 255;
          data[i + 2] = 255;
          data[i + 3] = 255;
        }

        // Update and draw each particle
        for (let particle of particles) {
          // Update position
          particle.x += particle.vx;
          particle.y += particle.vy;

          // Bounce off walls
          if (particle.x < 0 || particle.x >= width) {
            particle.vx *= -1;
            particle.x = Math.max(0, Math.min(width - 1, particle.x));
          }
          if (particle.y < 0 || particle.y >= height) {
            particle.vy *= -1;
            particle.y = Math.max(0, Math.min(height - 1, particle.y));
          }

          // Draw particle (black pixel)
          const px = Math.floor(particle.x);
          const py = Math.floor(particle.y);

          if (px >= 0 && px < width && py >= 0 && py < height) {
            const index = (py * width + px) * 4;
            data[index + 0] = 0; // R
            data[index + 1] = 0; // G
            data[index + 2] = 0; // B
            data[index + 3] = 255; // A
          }
        }

        ctx.putImageData(imageData, 0, 0);

        // Update FPS counter with rolling average
        const currentTime = performance.now();
        const frameInterval = currentTime - lastFrameTime;
        lastFrameTime = currentTime;

        // Add to rolling average
        frameIntervals.push(frameInterval);
        if (frameIntervals.length > maxIntervals) {
          frameIntervals.shift();
        }

        // Calculate average frame interval and convert to FPS
        const avgInterval = frameIntervals.reduce((a, b) => a + b, 0) / frameIntervals.length;
        const fps = Math.round(1000 / avgInterval);
        fpsDisplay.textContent = fps;

        if (animating) {
          animationId = requestAnimationFrame(animateFrame);
        }
      }

      // Start animation
      function startAnimation() {
        if (animating) return;

        animating = true;
        document.querySelector("button").disabled = true;

        createParticles();
        animateFrame();
      }

      // Initialize
      reset();
    </script>
  </body>
</html>
