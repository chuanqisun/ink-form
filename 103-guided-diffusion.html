<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL2 Particle System with Stroke Canvas</title>
  </head>
  <body>
    <canvas id="particleCanvas" width="300" height="600" style="border: 4px double #000"></canvas>
    <canvas id="strokeCanvas" width="300" height="600" style="border: 4px double #000"></canvas>
    <br />
    <button commandfor="connection-dialog" command="show-modal">Setup</button>
    <button id="clearBtn">Clear</button>
    <div>Particles: <span id="count">0</span></div>
    <div>FPS: <span id="fps">0</span></div>

    <dialog class="connection-form" id="connection-dialog">
      <div class="connections-dialog-body">
        <form method="dialog" id="ai-connection-form">
          <h2>Google AI Studio Connection</h2>
          <label for="api-key-input">API Key:</label>
          <input type="password" id="api-key-input" placeholder="Enter your Google AI Studio API key" />
          <button type="button" id="connect-btn">Connect</button>
          <button type="button" id="disconnect-btn" style="display: none">Disconnect</button>
          <button type="submit">Close</button>
          <div id="connection-status"></div>
        </form>
      </div>
    </dialog>

    <script>
      class PerformanceMonitor {
        constructor() {
          this.frameTimes = [];
          this.lastTime = 0;
        }

        update(currentTime) {
          if (this.lastTime > 0) {
            const delta = currentTime - this.lastTime;
            this.frameTimes.push(delta);
            if (this.frameTimes.length > 10) {
              this.frameTimes.shift();
            }
          }
          this.lastTime = currentTime;
          return this.getFPS();
        }

        getFPS() {
          if (this.frameTimes.length === 0) return 0;
          const avg = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
          return Math.round(1000 / avg);
        }
      }

      class AIConnection {
        constructor() {
          this.apiKey = null;
          this.isConnected = false;
          this.initEventListeners();
          this.loadApiKey();
        }

        initEventListeners() {
          const connectBtn = document.getElementById("connect-btn");
          const disconnectBtn = document.getElementById("disconnect-btn");
          const apiKeyInput = document.getElementById("api-key-input");

          connectBtn.addEventListener("click", () => this.connect());
          disconnectBtn.addEventListener("click", () => this.disconnect());

          // Allow Enter key to connect
          apiKeyInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              this.connect();
            }
          });
        }

        loadApiKey() {
          const stored = localStorage.getItem("google_ai_api_key");
          if (stored) {
            this.apiKey = stored;
            this.setConnected(true);
          }
        }

        connect() {
          const apiKeyInput = document.getElementById("api-key-input");
          const apiKey = apiKeyInput.value.trim();

          if (!apiKey) {
            this.updateStatus("Please enter an API key", "error");
            return;
          }

          // Store the API key
          this.apiKey = apiKey;
          localStorage.setItem("google_ai_api_key", apiKey);
          this.setConnected(true);
          this.updateStatus("Connected successfully!", "success");
        }

        disconnect() {
          this.apiKey = null;
          localStorage.removeItem("google_ai_api_key");
          this.setConnected(false);
          document.getElementById("api-key-input").value = "";
          this.updateStatus("Disconnected", "info");
        }

        setConnected(connected) {
          this.isConnected = connected;
          const connectBtn = document.getElementById("connect-btn");
          const disconnectBtn = document.getElementById("disconnect-btn");
          const apiKeyInput = document.getElementById("api-key-input");

          if (connected) {
            connectBtn.style.display = "none";
            disconnectBtn.style.display = "inline-block";
            apiKeyInput.disabled = true;
            apiKeyInput.value = this.apiKey;
          } else {
            connectBtn.style.display = "inline-block";
            disconnectBtn.style.display = "none";
            apiKeyInput.disabled = false;
            apiKeyInput.value = "";
          }
        }

        updateStatus(message, type = "info") {
          const statusDiv = document.getElementById("connection-status");
          statusDiv.textContent = message;
          statusDiv.style.color = type === "error" ? "red" : type === "success" ? "green" : "blue";
        }

        getApiKey() {
          return this.apiKey;
        }

        isAPIConnected() {
          return this.isConnected;
        }
      }

      /**
       * Converts images to pure black and white using Otsu's thresholding method.
       * This preserves edges and provides excellent contrast.
       */
      class ImageProcessor {
        /**
         * Convert any image to black and white guide strokes
         * @param {Blob|File} blob - Image blob to process
         * @param {number} maxWidth - Maximum width to scale to
         * @param {number} maxHeight - Maximum height to scale to
         * @returns {Promise<Object>} Object containing { imageData, scaledWidth, scaledHeight, offsetX, offsetY }
         */
        static async processImage(blob, maxWidth, maxHeight) {
          return new Promise((resolve, reject) => {
            const url = URL.createObjectURL(blob);
            const img = new Image();

            img.onload = () => {
              try {
                const { imageData, scaledWidth, scaledHeight, offsetX, offsetY } = ImageProcessor.convertToBlackAndWhite(img, maxWidth, maxHeight);

                URL.revokeObjectURL(url);
                resolve({ imageData, scaledWidth, scaledHeight, offsetX, offsetY });
              } catch (error) {
                URL.revokeObjectURL(url);
                reject(error);
              }
            };

            img.onerror = () => {
              URL.revokeObjectURL(url);
              reject(new Error("Failed to load image"));
            };

            img.src = url;
          });
        }

        /**
         * Calculate optimal threshold using Otsu's method
         * @param {Uint8Array} grayscaleData - Grayscale pixel values
         * @returns {number} Optimal threshold value (0-255)
         */
        static calculateOtsuThreshold(grayscaleData) {
          // Build histogram
          const histogram = new Array(256).fill(0);
          for (let i = 0; i < grayscaleData.length; i++) {
            histogram[grayscaleData[i]]++;
          }

          // Total number of pixels
          const total = grayscaleData.length;

          let sum = 0;
          for (let i = 0; i < 256; i++) {
            sum += i * histogram[i];
          }

          let sumB = 0;
          let wB = 0;
          let wF = 0;
          let maxVariance = 0;
          let threshold = 0;

          for (let i = 0; i < 256; i++) {
            wB += histogram[i];
            if (wB === 0) continue;

            wF = total - wB;
            if (wF === 0) break;

            sumB += i * histogram[i];

            const mB = sumB / wB;
            const mF = (sum - sumB) / wF;

            const variance = wB * wF * (mB - mF) * (mB - mF);

            if (variance > maxVariance) {
              maxVariance = variance;
              threshold = i;
            }
          }

          return threshold;
        }

        /**
         * Convert an image element to pure black and white
         * @param {HTMLImageElement} img - Image element to convert
         * @param {number} maxWidth - Maximum width to scale to
         * @param {number} maxHeight - Maximum height to scale to
         * @returns {Object} Object containing imageData and scaling information
         */
        static convertToBlackAndWhite(img, maxWidth, maxHeight) {
          // Calculate scaling to fit container while maintaining aspect ratio
          const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
          const scaledWidth = img.width * scale;
          const scaledHeight = img.height * scale;
          const offsetX = (maxWidth - scaledWidth) / 2;
          const offsetY = (maxHeight - scaledHeight) / 2;

          // Draw image to temporary canvas at original size
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = img.width;
          tempCanvas.height = img.height;
          const tempCtx = tempCanvas.getContext("2d");
          tempCtx.drawImage(img, 0, 0);

          // Get image data
          const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
          const data = imageData.data;

          // First pass: Convert to grayscale using luminosity method
          const grayscale = new Uint8Array(img.width * img.height);
          for (let i = 0; i < data.length; i += 4) {
            const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
            grayscale[i / 4] = gray;
          }

          // Calculate optimal threshold using Otsu's method
          const threshold = ImageProcessor.calculateOtsuThreshold(grayscale);

          // Second pass: Apply threshold to create pure black and white
          for (let i = 0; i < grayscale.length; i++) {
            const bw = grayscale[i] > threshold ? 255 : 0;
            data[i * 4] = bw;
            data[i * 4 + 1] = bw;
            data[i * 4 + 2] = bw;
            data[i * 4 + 3] = 255; // Ensure alpha is fully opaque
          }

          return {
            imageData,
            scaledWidth,
            scaledHeight,
            offsetX,
            offsetY,
          };
        }

        /**
         * Apply guide strokes to a canvas context
         * @param {CanvasRenderingContext2D} ctx - Canvas context to draw to
         * @param {ImageData} imageData - Processed image data (grayscale)
         * @param {number} srcWidth - Source image width
         * @param {number} srcHeight - Source image height
         * @param {number} destX - Destination X coordinate on canvas
         * @param {number} destY - Destination Y coordinate on canvas
         * @param {number} destWidth - Destination width on canvas
         * @param {number} destHeight - Destination height on canvas
         */
        static applyGuidesToCanvas(ctx, imageData, srcWidth, srcHeight, destX, destY, destWidth, destHeight) {
          // Create temporary canvas from processed imageData
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = srcWidth;
          tempCanvas.height = srcHeight;
          const tempCtx = tempCanvas.getContext("2d");
          tempCtx.putImageData(imageData, 0, 0);

          // Draw to destination canvas with scaling
          ctx.drawImage(tempCanvas, 0, 0, srcWidth, srcHeight, destX, destY, destWidth, destHeight);
        }
      }

      class StrokeCanvas {
        constructor(canvasId, strokeWidth = 2) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.isDrawing = false;
          this.ctx.lineWidth = strokeWidth;
          this.ctx.lineCap = "round";
          this.ctx.strokeStyle = "#000";
          this.listeners = {
            strokeUpdated: [],
            imageLoaded: [],
          };
        }

        // Event system for decoupling
        on(event, callback) {
          if (this.listeners[event]) {
            this.listeners[event].push(callback);
          }
        }

        emit(event, data) {
          if (this.listeners[event]) {
            this.listeners[event].forEach((callback) => callback(data));
          }
        }

        startDrawing(x, y) {
          this.isDrawing = true;
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
        }

        draw(x, y) {
          if (!this.isDrawing) return;
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
          this.emit("strokeUpdated", { type: "draw" });
        }

        stopDrawing() {
          this.isDrawing = false;
          this.emit("strokeUpdated", { type: "complete" });
        }

        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.emit("strokeUpdated", { type: "clear" });
        }

        getImageData() {
          return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        }

        /**
         * Set image from a Blob or File as guide strokes
         * Automatically converts colored images to grayscale for use as force field
         */
        async setImageFromBlob(blob) {
          try {
            const { imageData, scaledWidth, scaledHeight, offsetX, offsetY } = await ImageProcessor.processImage(blob, this.canvas.width, this.canvas.height);

            // Clear canvas first
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // Apply processed guide strokes to canvas
            ImageProcessor.applyGuidesToCanvas(this.ctx, imageData, imageData.width, imageData.height, offsetX, offsetY, scaledWidth, scaledHeight);

            // Emit event for new image loaded
            this.emit("imageLoaded", { imageData, scaledWidth, scaledHeight, offsetX, offsetY });
          } catch (error) {
            console.error("Failed to process image:", error);
          }
        }
      }

      class ParticleSystem {
        constructor(particleCanvasId, strokeCanvasId) {
          this.canvas = document.getElementById(particleCanvasId);
          this.ctx = this.canvas.getContext("2d");

          // Debug stroke canvas (persistent)
          this.strokeCanvas = new StrokeCanvas(strokeCanvasId, 2);

          // Temporary canvas for capturing current stroke segment
          this.tempCanvas = document.createElement("canvas");
          this.tempCanvas.width = this.canvas.width;
          this.tempCanvas.height = this.canvas.height;
          this.tempCtx = this.tempCanvas.getContext("2d");
          this.tempCtx.lineWidth = 1; // Small width to limit particle count
          this.tempCtx.lineCap = "round";
          this.tempCtx.strokeStyle = "#000";

          this.maxParticles = 100000;
          this.particles = [];
          this.isPointerDown = false;
          this.lastAddTime = 0;
          this.pointerPos = { x: 0, y: 0 };
          this.perfMonitor = new PerformanceMonitor();
          this.isDrawing = false;

          // Cache for force field calculations
          this.distanceField = null;
          this.nearestStrokeX = null;
          this.nearestStrokeY = null;
          this.gradientField = null;
          this.lastStrokeUpdate = 0;

          this.initEventListeners();
          this.setupStrokeCanvasListeners();
          this.animate();
        }

        /**
         * Setup listeners for stroke canvas events (decoupled communication)
         */
        setupStrokeCanvasListeners() {
          // Listen for new image loaded events
          this.strokeCanvas.on("imageLoaded", () => {
            this.handleNewGuideImage();
          });

          // Listen for stroke updates to invalidate cache
          this.strokeCanvas.on("strokeUpdated", ({ type }) => {
            if (type === "clear") {
              this.particles = [];
              document.getElementById("count").textContent = 0;
              // Invalidate force field cache on clear
              this.distanceField = null;
              this.gradientField = null;
            }
          });
        }

        /**
         * Handle new guide image by resetting all particles to diffusion phase
         * This naturally triggers phases 1 and 2 to re-run
         */
        handleNewGuideImage() {
          const now = performance.now();
          const particleCount = this.particles.length;

          // Reset all existing particles to start fresh diffusion
          this.particles.forEach((particle) => {
            particle.birthTime = now;
            particle.phase = "diffusion";

            // Give particles new random initial velocities for diffusion
            const speed = 3 + Math.random() * 2;
            const angle = Math.random() * Math.PI * 2;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;
          });

          // Invalidate force field cache to rebuild with new image
          this.distanceField = null;
          this.nearestStrokeX = null;
          this.nearestStrokeY = null;
          this.gradientField = null;

          console.log(`New guide image loaded - ${particleCount} particles reset to diffusion phase`);
        }

        initEventListeners() {
          this.canvas.addEventListener("pointerdown", (e) => {
            this.isPointerDown = true;
            this.isDrawing = true;
            this.updatePointerPos(e);

            // Start drawing on both canvases
            this.strokeCanvas.startDrawing(this.pointerPos.x, this.pointerPos.y);

            // Start drawing on particle canvas (visible)
            this.ctx.lineWidth = 1;
            this.ctx.lineCap = "round";
            this.ctx.strokeStyle = "#000";
            this.ctx.beginPath();
            this.ctx.moveTo(this.pointerPos.x, this.pointerPos.y);

            // Start drawing on temp canvas (for particle conversion)
            this.tempCtx.clearRect(0, 0, this.tempCanvas.width, this.tempCanvas.height);
            this.tempCtx.beginPath();
            this.tempCtx.moveTo(this.pointerPos.x, this.pointerPos.y);
          });

          this.canvas.addEventListener("pointermove", (e) => {
            this.updatePointerPos(e);
            if (this.isPointerDown && this.isDrawing) {
              // Draw on debug canvas
              this.strokeCanvas.draw(this.pointerPos.x, this.pointerPos.y);

              // Draw on particle canvas (visible)
              this.ctx.lineTo(this.pointerPos.x, this.pointerPos.y);
              this.ctx.stroke();

              // Draw on temp canvas (for particle conversion)
              this.tempCtx.lineTo(this.pointerPos.x, this.pointerPos.y);
              this.tempCtx.stroke();
            }
          });

          this.canvas.addEventListener("pointerup", () => {
            if (this.isDrawing) {
              this.convertStrokeToParticles();
            }
            this.isPointerDown = false;
            this.isDrawing = false;
            this.strokeCanvas.stopDrawing();
          });

          this.canvas.addEventListener("pointerout", () => {
            if (this.isDrawing) {
              this.convertStrokeToParticles();
            }
            this.isPointerDown = false;
            this.isDrawing = false;
            this.strokeCanvas.stopDrawing();
          });

          // Handle image paste events
          document.addEventListener("paste", (e) => this.handlePaste(e));

          document.getElementById("clearBtn").addEventListener("click", () => this.clear());
        }

        handlePaste(e) {
          const items = e.clipboardData?.items;
          if (!items) return;

          for (const item of items) {
            if (item.type.startsWith("image/")) {
              e.preventDefault();
              const blob = item.getAsFile();
              if (blob) {
                this.strokeCanvas.setImageFromBlob(blob);
              }
              break;
            }
          }
        }

        updatePointerPos(e) {
          const rect = this.canvas.getBoundingClientRect();
          this.pointerPos.x = e.clientX - rect.left;
          this.pointerPos.y = e.clientY - rect.top;
        }

        convertStrokeToParticles() {
          // Get the image data from the temporary canvas
          const imageData = this.tempCtx.getImageData(0, 0, this.tempCanvas.width, this.tempCanvas.height);
          const data = imageData.data;

          let particlesAdded = 0;
          const maxParticlesToAdd = this.maxParticles - this.particles.length;

          // Scan the entire canvas and create particles at non-transparent pixels
          for (let y = 0; y < imageData.height && particlesAdded < maxParticlesToAdd; y++) {
            for (let x = 0; x < imageData.width && particlesAdded < maxParticlesToAdd; x++) {
              const index = (y * imageData.width + x) * 4;
              const alpha = data[index + 3];

              // If there's a stroke at this position, create a particle
              if (alpha > 0) {
                // Phase 1: Diffusion - particles start with significant initial velocity
                const speed = 3 + Math.random() * 2; // Random speed between 3-5
                const angle = Math.random() * Math.PI * 2; // Random direction

                this.particles.push({
                  x: x,
                  y: y,
                  vx: Math.cos(angle) * speed,
                  vy: Math.sin(angle) * speed,
                  birthTime: performance.now(), // Track when particle was created
                  phase: "diffusion", // Start in diffusion phase
                });
                particlesAdded++;
              }
            }
          }

          document.getElementById("count").textContent = this.particles.length;

          // Clear the temporary canvas for the next stroke
          this.tempCtx.clearRect(0, 0, this.tempCanvas.width, this.tempCanvas.height);
        }

        /**
         * Compute distance transform AND nearest stroke pixel for each position
         * Returns object with distance field and nearest pixel coordinates (global analysis)
         */
        computeDistanceField(strokeData, width, height) {
          const dist = new Float32Array(width * height);
          const nearestX = new Int16Array(width * height);
          const nearestY = new Int16Array(width * height);
          const INF = width + height; // Large enough value

          // Initialize distances and nearest pixels
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const i = y * width + x;
              const alpha = strokeData[i * 4 + 3];
              if (alpha > 0) {
                dist[i] = 0;
                nearestX[i] = x;
                nearestY[i] = y;
              } else {
                dist[i] = INF;
                nearestX[i] = -1;
                nearestY[i] = -1;
              }
            }
          }

          // Forward pass - propagate nearest stroke pixel info
          for (let y = 1; y < height; y++) {
            for (let x = 1; x < width; x++) {
              const i = y * width + x;
              if (dist[i] > 0) {
                // Check neighbors and update if they provide shorter path
                const neighbors = [
                  { idx: i - 1, dx: 1, dy: 0 }, // left
                  { idx: i - width, dx: 0, dy: 1 }, // top
                  { idx: i - width - 1, dx: 1, dy: 1 }, // top-left
                  { idx: i - width + 1, dx: -1, dy: 1 }, // top-right
                ];

                for (const { idx, dx, dy } of neighbors) {
                  if (nearestX[idx] >= 0) {
                    const nx = nearestX[idx];
                    const ny = nearestY[idx];
                    const newDist = Math.sqrt((x - nx) ** 2 + (y - ny) ** 2);

                    if (newDist < dist[i]) {
                      dist[i] = newDist;
                      nearestX[i] = nx;
                      nearestY[i] = ny;
                    }
                  }
                }
              }
            }
          }

          // Backward pass - refine nearest stroke pixel info
          for (let y = height - 2; y >= 0; y--) {
            for (let x = width - 2; x >= 0; x--) {
              const i = y * width + x;
              if (dist[i] > 0) {
                const neighbors = [
                  { idx: i + 1, dx: -1, dy: 0 }, // right
                  { idx: i + width, dx: 0, dy: -1 }, // bottom
                  { idx: i + width + 1, dx: -1, dy: -1 }, // bottom-right
                  { idx: i + width - 1, dx: 1, dy: -1 }, // bottom-left
                ];

                for (const { idx, dx, dy } of neighbors) {
                  if (nearestX[idx] >= 0) {
                    const nx = nearestX[idx];
                    const ny = nearestY[idx];
                    const newDist = Math.sqrt((x - nx) ** 2 + (y - ny) ** 2);

                    if (newDist < dist[i]) {
                      dist[i] = newDist;
                      nearestX[i] = nx;
                      nearestY[i] = ny;
                    }
                  }
                }
              }
            }
          }

          return { dist, nearestX, nearestY };
        }

        /**
         * Compute gradient field from distance transform
         * Particles follow gradient to move toward strokes
         */
        computeGradientField(distField, width, height) {
          const gradX = new Float32Array(width * height);
          const gradY = new Float32Array(width * height);

          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              const i = y * width + x;

              // Sobel operator for gradient
              const gx =
                distField[i - width - 1] * -1 +
                distField[i - width + 1] * 1 +
                distField[i - 1] * -2 +
                distField[i + 1] * 2 +
                distField[i + width - 1] * -1 +
                distField[i + width + 1] * 1;

              const gy =
                distField[i - width - 1] * -1 +
                distField[i - width] * -2 +
                distField[i - width + 1] * -1 +
                distField[i + width - 1] * 1 +
                distField[i + width] * 2 +
                distField[i + width + 1] * 1;

              gradX[i] = gx;
              gradY[i] = gy;
            }
          }

          return { gradX, gradY };
        }

        /**
         * Update force field cache when strokes change
         */
        updateForceFieldCache(strokeData, width, height) {
          const result = this.computeDistanceField(strokeData, width, height);
          this.distanceField = result.dist;
          this.nearestStrokeX = result.nearestX;
          this.nearestStrokeY = result.nearestY;
          this.gradientField = this.computeGradientField(this.distanceField, width, height);
        }

        update(deltaTime) {
          const strokeImageData = this.strokeCanvas.ctx.getImageData(0, 0, this.strokeCanvas.canvas.width, this.strokeCanvas.canvas.height);
          const strokeData = strokeImageData.data;
          const width = strokeImageData.width;
          const height = strokeImageData.height;

          // Update force field cache periodically or when strokes change
          const now = performance.now();
          if (!this.distanceField || now - this.lastStrokeUpdate > 100) {
            this.updateForceFieldCache(strokeData, width, height);
            this.lastStrokeUpdate = now;
          }

          for (const p of this.particles) {
            const age = (now - p.birthTime) / 1000; // Age in seconds

            // Phase transition timing
            const diffusionDuration = 0.5; // 0.5 seconds of diffusion
            const stabilizationDuration = 2.0; // 2 seconds to fully stabilize

            // Calculate progress through phases (0 = start diffusion, 1 = fully stabilized)
            const totalDuration = diffusionDuration + stabilizationDuration;
            const progress = Math.min(age / totalDuration, 1);

            // Phase 1: Diffusion (0 to diffusionDuration seconds)
            if (age < diffusionDuration) {
              p.phase = "diffusion";

              // High randomness during diffusion
              const randomStrength = 2.0 * (1 - age / diffusionDuration); // Decreases over time
              p.vx += (Math.random() - 0.5) * randomStrength;
              p.vy += (Math.random() - 0.5) * randomStrength;

              // Minimal damping - let particles spread
              p.vx *= 0.98;
              p.vy *= 0.98;
            }
            // Phase 2: Stabilization (diffusionDuration to totalDuration seconds)
            else {
              p.phase = "stabilization";

              // Calculate stabilization progress (0 = just started, 1 = fully stabilized)
              const stabilizationProgress = (age - diffusionDuration) / stabilizationDuration;
              const stabilizationFactor = Math.min(stabilizationProgress, 1);

              // Apply force field with increasing strength as stabilization progresses
              this.applyStabilizationForce(p, width, height, stabilizationFactor);

              // Reduce randomness as stabilization progresses
              const randomStrength = 0.5 * (1 - stabilizationFactor);
              p.vx += (Math.random() - 0.5) * randomStrength;
              p.vy += (Math.random() - 0.5) * randomStrength;

              // Increase damping as stabilization progresses
              const dampingFactor = 0.98 - stabilizationFactor * 0.15; // 0.98 to 0.83
              p.vx *= dampingFactor;
              p.vy *= dampingFactor;

              // Final stabilization: snap to nearest stroke pixel
              if (stabilizationFactor > 0.95) {
                this.snapToStroke(p, strokeData, width, height);
              }
            }

            // Update position
            p.x += p.vx;
            p.y += p.vy;

            // Boundary conditions with bounce
            if (p.x < 0 || p.x > this.canvas.width) {
              p.vx *= -0.8;
              p.x = Math.max(0, Math.min(this.canvas.width, p.x));
            }
            if (p.y < 0 || p.y > this.canvas.height) {
              p.vy *= -0.8;
              p.y = Math.max(0, Math.min(this.canvas.height, p.y));
            }
          }
        }

        /**
         * Apply stabilization force - particles gradually move toward nearest stroke
         * @param {Object} particle - The particle to apply force to
         * @param {number} width - Canvas width
         * @param {number} height - Canvas height
         * @param {number} stabilizationFactor - 0 (just started) to 1 (fully stabilized)
         */
        applyStabilizationForce(particle, width, height, stabilizationFactor) {
          const x = Math.floor(particle.x);
          const y = Math.floor(particle.y);

          // Bounds check
          if (x < 1 || x >= width - 1 || y < 1 || y >= height - 1) return;

          const i = y * width + x;

          if (!this.distanceField || !this.gradientField) return;

          const distance = this.distanceField[i];
          const gradX = this.gradientField.gradX[i];
          const gradY = this.gradientField.gradY[i];

          // Force strength increases as stabilization progresses
          const baseStrength = 0.1 + stabilizationFactor * 1.5; // 0.1 to 1.6

          // Distance-based force adjustment
          let strength = baseStrength;
          if (distance > 10) {
            // Far particles need stronger pull
            strength *= 2;
          } else if (distance < 2) {
            // Close particles need gentle adjustment
            strength *= 0.5;
          }

          const magnitude = Math.sqrt(gradX * gradX + gradY * gradY);

          if (magnitude > 0.01) {
            // Normalize and apply force toward stroke
            particle.vx -= (gradX / magnitude) * strength;
            particle.vy -= (gradY / magnitude) * strength;
          }
        }

        /**
         * Snap particle to the nearest stroke pixel (final stabilization using global position)
         * @param {Object} particle - The particle to snap
         * @param {Uint8ClampedArray} strokeData - Stroke canvas image data
         * @param {number} width - Canvas width
         * @param {number} height - Canvas height
         */
        snapToStroke(particle, strokeData, width, height) {
          const x = Math.floor(particle.x);
          const y = Math.floor(particle.y);

          // Bounds check
          if (x < 0 || x >= width || y < 0 || y >= height) return;

          const i = y * width + x;

          // If already on a stroke, lock in place
          if (strokeData[i * 4 + 3] > 0) {
            particle.vx *= 0.1;
            particle.vy *= 0.1;
            return;
          }

          // Use global nearest stroke position
          if (!this.nearestStrokeX || !this.nearestStrokeY) return;

          const nearestX = this.nearestStrokeX[i];
          const nearestY = this.nearestStrokeY[i];

          if (nearestX < 0 || nearestY < 0) return;

          // Calculate direct vector to nearest stroke pixel
          const dx = nearestX - particle.x;
          const dy = nearestY - particle.y;
          const distToTarget = Math.sqrt(dx * dx + dy * dy);

          // If very close, snap directly to target
          if (distToTarget < 2) {
            // Strong pull toward exact stroke position
            particle.vx = dx * 0.5;
            particle.vy = dy * 0.5;

            // If extremely close, lock position
            if (distToTarget < 0.5) {
              particle.x = nearestX;
              particle.y = nearestY;
              particle.vx = 0;
              particle.vy = 0;
            }
          }
        }

        render() {
          this.ctx.fillStyle = "black";
          for (const p of this.particles) {
            this.ctx.fillRect(p.x, p.y, 1, 1);
          }

          // Draw temporary canvas content (current stroke being drawn)
          this.ctx.drawImage(this.tempCanvas, 0, 0);
        }

        clear() {
          this.particles = [];
          document.getElementById("count").textContent = 0;
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.strokeCanvas.clear();
        }

        animate(currentTime = 0) {
          const deltaTime = Math.min((currentTime - (this.lastTime || currentTime)) / 1000, 0.1);
          this.lastTime = currentTime;

          const fps = this.perfMonitor.update(currentTime);
          document.getElementById("fps").textContent = fps;

          // Always update particles
          this.update(deltaTime);

          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Always render particles
          this.render();

          requestAnimationFrame((t) => this.animate(t));
        }
      }

      const aiConnection = new AIConnection();
      const particleSystem = new ParticleSystem("particleCanvas", "strokeCanvas");
    </script>
  </body>
</html>
