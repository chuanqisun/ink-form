<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL2 Particle System with Stroke Canvas</title>
  </head>
  <body>
    <canvas id="particleCanvas" width="300" height="600" style="border: 4px double #000"></canvas>
    <canvas id="strokeCanvas" width="300" height="600" style="border: 4px double #000; cursor: crosshair"></canvas>
    <br />
    <button id="clearParticlesBtn">Clear Particles</button>
    <button id="clearStrokeBtn">Clear Stroke</button>
    <button id="renderBtn">Render</button>
    <div>Particles: <span id="count">0</span></div>
    <div>FPS: <span id="fps">0</span></div>

    <script>
      // ============================================================================
      // Performance Monitoring
      // ============================================================================
      class PerformanceMonitor {
        constructor(sampleSize = 10) {
          this.frameTimes = [];
          this.sampleSize = sampleSize;
          this.lastTime = 0;
        }

        update(currentTime) {
          if (this.lastTime > 0) {
            this.frameTimes.push(currentTime - this.lastTime);
            if (this.frameTimes.length > this.sampleSize) this.frameTimes.shift();
          }
          this.lastTime = currentTime;
          return this.getFPS();
        }

        getFPS() {
          if (this.frameTimes.length === 0) return 0;
          const avgDelta = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
          return Math.round(1000 / avgDelta);
        }
      }

      // ============================================================================
      // Stroke Canvas - Handles user drawing input
      // ============================================================================
      class StrokeCanvas {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.isDrawing = false;
          this.lastHash = null;
          this._configureContext();
          this._initEventListeners();
        }

        _configureContext() {
          this.ctx.lineWidth = 2;
          this.ctx.lineCap = "round";
          this.ctx.strokeStyle = "#000";
        }

        _initEventListeners() {
          this.canvas.addEventListener("pointerdown", (e) => this._onPointerDown(e));
          this.canvas.addEventListener("pointermove", (e) => this._onPointerMove(e));
          this.canvas.addEventListener("pointerup", () => this._onPointerUp());
          this.canvas.addEventListener("pointerout", () => this._onPointerUp());
        }

        _onPointerDown(e) {
          this.isDrawing = true;
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
        }

        _onPointerMove(e) {
          if (!this.isDrawing) return;
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
        }

        _onPointerUp() {
          this.isDrawing = false;
        }

        startDrawing(x, y) {
          this.isDrawing = true;
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
        }

        draw(x, y) {
          if (!this.isDrawing) return;
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
        }

        stopDrawing() {
          this.isDrawing = false;
        }

        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.lastHash = null;
        }

        getImageData() {
          return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        }

        /**
         * Check if the stroke canvas content has changed since last check
         * @returns {boolean} true if content has changed, false otherwise
         */
        hasChanged() {
          const imageData = this.getImageData();
          const currentHash = this._computeHash(imageData.data);
          const hasChanged = this.lastHash === null || this.lastHash !== currentHash;
          this.lastHash = currentHash;
          return hasChanged;
        }

        /**
         * Compute a simple hash of the image data for change detection
         * @private
         */
        _computeHash(data) {
          let hash = 0;
          // Sample every 100th pixel for performance
          for (let i = 0; i < data.length; i += 400) {
            hash = (hash << 5) - hash + data[i];
            hash = hash & hash; // Convert to 32bit integer
          }
          return hash.toString();
        }

        get width() {
          return this.canvas.width;
        }
        get height() {
          return this.canvas.height;
        }
      }

      // ============================================================================
      // Particle System - Manages particle simulation and physics
      // ============================================================================
      class ParticleSystem {
        constructor(maxParticles = 100000) {
          this.maxParticles = maxParticles;
          this.particles = [];
          this.config = {
            spawnRadius: 30,
            searchRadius: 50,
            attractionStrength: 0.5,
            randomness: 0.5,
            damping: 0.99,
            wallBounce: 0.8,
          };
        }

        addParticles(count, spawnX, spawnY) {
          const available = this.maxParticles - this.particles.length;
          if (available <= 0) return 0;

          const toAdd = Math.min(count, available);
          const { spawnRadius } = this.config;

          for (let i = 0; i < toAdd; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spawnRadius;

            this.particles.push({
              x: spawnX + Math.cos(angle) * distance,
              y: spawnY + Math.sin(angle) * distance,
              vx: (Math.random() - 0.5) * 2,
              vy: (Math.random() - 0.5) * 2,
              settled: false,
            });
          }

          return toAdd;
        }

        update(strokeImageData, canvasWidth, canvasHeight) {
          const { data: strokeData, width: imgWidth, height: imgHeight } = strokeImageData;

          for (const particle of this.particles) {
            if (particle.settled) continue;

            if (this._checkSettlement(particle, strokeData, imgWidth, imgHeight)) {
              particle.settled = true;
              particle.vx = particle.vy = 0;
              continue;
            }

            this._applyForceField(particle, strokeData, imgWidth, imgHeight);
            this._applyRandomness(particle);
            this._applyDamping(particle);
            this._updatePosition(particle);
            this._handleBoundaries(particle, canvasWidth, canvasHeight);
          }
        }

        _checkSettlement(particle, strokeData, width, height) {
          const px = Math.floor(particle.x);
          const py = Math.floor(particle.y);

          if (px < 0 || px >= width || py < 0 || py >= height) return false;

          const index = (py * width + px) * 4;
          return strokeData[index + 3] > 0; // Check alpha channel
        }

        _applyForceField(particle, strokeData, width, height) {
          const { searchRadius, attractionStrength } = this.config;
          const closest = this._findClosestStrokePixel(particle, strokeData, width, height, searchRadius);

          if (!closest) return;

          const dx = closest.x - particle.x;
          const dy = closest.y - particle.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            const force = attractionStrength / (1 + dist * 0.1);
            particle.vx += (dx / dist) * force;
            particle.vy += (dy / dist) * force;
          }
        }

        _findClosestStrokePixel(particle, strokeData, width, height, searchRadius) {
          const startX = Math.max(0, Math.floor(particle.x - searchRadius));
          const endX = Math.min(width - 1, Math.ceil(particle.x + searchRadius));
          const startY = Math.max(0, Math.floor(particle.y - searchRadius));
          const endY = Math.min(height - 1, Math.ceil(particle.y + searchRadius));

          let closestDist = Infinity;
          let closest = null;

          for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
              const index = (y * width + x) * 4;
              if (strokeData[index + 3] === 0) continue; // No stroke here

              const dx = x - particle.x;
              const dy = y - particle.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              if (dist < closestDist && dist > 0) {
                closestDist = dist;
                closest = { x, y };
              }
            }
          }

          return closest;
        }

        _applyRandomness(particle) {
          const { randomness } = this.config;
          particle.vx += (Math.random() - 0.5) * randomness;
          particle.vy += (Math.random() - 0.5) * randomness;
        }

        _applyDamping(particle) {
          const { damping } = this.config;
          particle.vx *= damping;
          particle.vy *= damping;
        }

        _updatePosition(particle) {
          particle.x += particle.vx;
          particle.y += particle.vy;
        }

        _handleBoundaries(particle, width, height) {
          const { wallBounce } = this.config;

          if (particle.x < 0 || particle.x > width) {
            particle.vx *= -wallBounce;
            particle.x = Math.max(0, Math.min(width, particle.x));
          }

          if (particle.y < 0 || particle.y > height) {
            particle.vy *= -wallBounce;
            particle.y = Math.max(0, Math.min(height, particle.y));
          }
        }

        clear() {
          this.particles = [];
        }

        get count() {
          return this.particles.length;
        }
      }

      // ============================================================================
      // Interactive Canvas - Orchestrates user interaction and rendering
      // ============================================================================
      class InteractiveCanvas {
        constructor(particleCanvasId, strokeCanvasId) {
          this.canvas = document.getElementById(particleCanvasId);
          this.ctx = this.canvas.getContext("2d");
          this.strokeCanvas = new StrokeCanvas(strokeCanvasId);
          this.particleSystem = new ParticleSystem(100000);
          this.perfMonitor = new PerformanceMonitor();

          this.state = {
            isPointerDown: false,
            pointerX: 0,
            pointerY: 0,
            prevPointerX: 0,
            prevPointerY: 0,
            lastSpawnX: 0,
            lastSpawnY: 0,
            accumulatedDistance: 0,
            lastMoveTime: 0,
            velocity: 0, // Current cursor velocity in pixels per frame
          };

          this.spawnConfig = {
            spawnSpacing: 8, // Pixels between spawn points for even distribution
            pauseThreshold: 100, // Milliseconds of no movement before stopping spawns
            particlesPerSpawn: 5, // Particles spawned at each interval
            maxVelocity: 50, // Maximum velocity cap for particle count scaling
          };

          this._initEventListeners();
          this._startAnimationLoop();
        }

        _initEventListeners() {
          this.canvas.addEventListener("pointerdown", (e) => this._onPointerDown(e));
          this.canvas.addEventListener("pointermove", (e) => this._onPointerMove(e));
          this.canvas.addEventListener("pointerup", () => this._onPointerUp());
          this.canvas.addEventListener("pointerout", () => this._onPointerUp());
          document.getElementById("clearParticlesBtn").addEventListener("click", () => this.clearParticles());
          document.getElementById("clearStrokeBtn").addEventListener("click", () => this.clearStroke());
          document.getElementById("renderBtn").addEventListener("click", () => this.render());
        }

        _onPointerDown(e) {
          this.state.isPointerDown = true;
          this._updatePointerPosition(e);
          this.strokeCanvas.startDrawing(this.state.pointerX, this.state.pointerY);
          // Initialize spawn tracking at pointer down
          this.state.lastSpawnX = this.state.pointerX;
          this.state.lastSpawnY = this.state.pointerY;
          this.state.prevPointerX = this.state.pointerX;
          this.state.prevPointerY = this.state.pointerY;
          this.state.accumulatedDistance = 0;
          this.state.lastMoveTime = performance.now();
        }

        _onPointerMove(e) {
          this._updatePointerPosition(e);
          if (this.state.isPointerDown) {
            this.strokeCanvas.draw(this.state.pointerX, this.state.pointerY);
          }
        }

        _onPointerUp() {
          this.state.isPointerDown = false;
          this.strokeCanvas.stopDrawing();
        }

        _updatePointerPosition(e) {
          const rect = this.canvas.getBoundingClientRect();
          const newX = e.clientX - rect.left;
          const newY = e.clientY - rect.top;

          // Calculate instantaneous velocity
          if (this.state.isPointerDown) {
            const dx = newX - this.state.pointerX;
            const dy = newY - this.state.pointerY;
            this.state.velocity = Math.sqrt(dx * dx + dy * dy);
            this.state.lastMoveTime = performance.now();
          }

          this.state.prevPointerX = this.state.pointerX;
          this.state.prevPointerY = this.state.pointerY;
          this.state.pointerX = newX;
          this.state.pointerY = newY;
        }

        _spawnParticles(currentTime) {
          if (!this.state.isPointerDown) return;

          // Check if user has stopped moving (pause detection)
          const timeSinceLastMove = currentTime - this.state.lastMoveTime;
          if (timeSinceLastMove > this.spawnConfig.pauseThreshold) {
            // User has paused, don't spawn more particles
            return;
          }

          // Get the interpolated path points between previous and current cursor position
          const pathPoints = this._getInterpolatedPath(
            this.state.lastSpawnX,
            this.state.lastSpawnY,
            this.state.pointerX,
            this.state.pointerY,
            this.spawnConfig.spawnSpacing
          );

          // Spawn particles at each interpolated point
          for (const point of pathPoints) {
            this.particleSystem.addParticles(this.spawnConfig.particlesPerSpawn, point.x, point.y);
          }

          if (pathPoints.length > 0) {
            this._updateParticleCount();
            // Update spawn position to current cursor position
            this.state.lastSpawnX = this.state.pointerX;
            this.state.lastSpawnY = this.state.pointerY;
          }
        }

        /**
         * Generate interpolated points along the path from start to end
         * Using a line-drawing-like algorithm to ensure even spacing and no gaps
         * @private
         */
        _getInterpolatedPath(startX, startY, endX, endY, spacing) {
          const points = [];
          const dx = endX - startX;
          const dy = endY - startY;
          const totalDistance = Math.sqrt(dx * dx + dy * dy);

          if (totalDistance < spacing) {
            // Distance is too small, don't spawn yet
            return points;
          }

          // Calculate number of spawn points needed to cover the distance
          const numPoints = Math.floor(totalDistance / spacing);

          for (let i = 1; i <= numPoints; i++) {
            const t = i / (numPoints + 1);
            points.push({
              x: startX + dx * t,
              y: startY + dy * t,
            });
          }

          return points;
        }

        _updateParticleCount() {
          document.getElementById("count").textContent = this.particleSystem.count;
        }

        _updateFPS(fps) {
          document.getElementById("fps").textContent = fps;
        }

        _render() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.fillStyle = "black";

          for (const particle of this.particleSystem.particles) {
            this.ctx.fillRect(particle.x, particle.y, 1, 1);
          }
        }

        _startAnimationLoop() {
          const animate = (currentTime) => {
            const fps = this.perfMonitor.update(currentTime);
            this._updateFPS(fps);

            this._spawnParticles(currentTime);

            const strokeImageData = this.strokeCanvas.getImageData();
            this.particleSystem.update(strokeImageData, this.canvas.width, this.canvas.height);

            this._render();

            requestAnimationFrame(animate);
          };

          requestAnimationFrame(animate);
        }

        clear() {
          this.particleSystem.clear();
          this._updateParticleCount();
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.strokeCanvas.clear();
        }

        clearParticles() {
          this.particleSystem.clear();
          this._updateParticleCount();
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }

        clearStroke() {
          this.strokeCanvas.clear();
        }

        /**
         * Render method: updates the particle system force guide if stroke canvas has changed
         * Only affects existing particles by updating their force guide, does not spawn new particles
         */
        render() {
          if (!this.strokeCanvas.hasChanged()) {
            // No changes detected, don't disturb the particle system
            return;
          }

          // If we reach here, the stroke canvas has changed
          // The particle system will automatically use the updated stroke content
          // in its next update() call via getImageData()
        }
      }

      // ============================================================================
      // Initialize Application
      // ============================================================================
      const app = new InteractiveCanvas("particleCanvas", "strokeCanvas");
    </script>
  </body>
</html>
