<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dual Canvas Drawing</title>
  </head>
  <body>
    <canvas id="DrawCanvas" width="300" height="600" style="border: 1px solid black"></canvas>
    <canvas id="GenerativeCanvas" width="300" height="600" style="border: 1px solid black"></canvas>
    <canvas id="StylizeCanvas" width="300" height="600" style="border: 1px solid black"></canvas>
    <canvas id="AnimateCanvas" width="300" height="600" style="border: 1px solid black"></canvas>
    <br />
    <button commandfor="connection-dialog" command="show-modal">Setup</button>

    <dialog class="connection-form" id="connection-dialog">
      <div class="connections-dialog-body">
        <form method="dialog" id="ai-connection-form">
          <h2>Google AI Studio Connection</h2>
          <label for="api-key-input">API Key:</label>
          <input type="password" id="api-key-input" placeholder="Enter your Google AI Studio API key" />
          <button type="button" id="connect-btn">Connect</button>
          <button type="button" id="disconnect-btn" style="display: none">Disconnect</button>
          <button type="submit">Close</button>
          <div id="connection-status"></div>
        </form>
      </div>
    </dialog>
    <script>
      class AIConnection {
        constructor() {
          this.apiKey = null;
          this.isConnected = false;
          this.initEventListeners();
          this.loadApiKey();
        }

        initEventListeners() {
          const connectBtn = document.getElementById("connect-btn");
          const disconnectBtn = document.getElementById("disconnect-btn");
          const apiKeyInput = document.getElementById("api-key-input");

          connectBtn.addEventListener("click", () => this.connect());
          disconnectBtn.addEventListener("click", () => this.disconnect());

          // Allow Enter key to connect
          apiKeyInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              this.connect();
            }
          });
        }

        loadApiKey() {
          const stored = localStorage.getItem("google_ai_api_key");
          if (stored) {
            this.apiKey = stored;
            this.setConnected(true);
          }
        }

        connect() {
          const apiKeyInput = document.getElementById("api-key-input");
          const apiKey = apiKeyInput.value.trim();

          if (!apiKey) {
            this.updateStatus("Please enter an API key", "error");
            return;
          }

          // Store the API key
          this.apiKey = apiKey;
          localStorage.setItem("google_ai_api_key", apiKey);
          this.setConnected(true);
          this.updateStatus("Connected successfully!", "success");
        }

        disconnect() {
          this.apiKey = null;
          localStorage.removeItem("google_ai_api_key");
          this.setConnected(false);
          document.getElementById("api-key-input").value = "";
          this.updateStatus("Disconnected", "info");
        }

        setConnected(connected) {
          this.isConnected = connected;
          const connectBtn = document.getElementById("connect-btn");
          const disconnectBtn = document.getElementById("disconnect-btn");
          const apiKeyInput = document.getElementById("api-key-input");

          if (connected) {
            connectBtn.style.display = "none";
            disconnectBtn.style.display = "inline-block";
            apiKeyInput.disabled = true;
            apiKeyInput.value = this.apiKey;
          } else {
            connectBtn.style.display = "inline-block";
            disconnectBtn.style.display = "none";
            apiKeyInput.disabled = false;
            apiKeyInput.value = "";
          }
        }

        updateStatus(message, type = "info") {
          const statusDiv = document.getElementById("connection-status");
          statusDiv.textContent = message;
          statusDiv.style.color = type === "error" ? "red" : type === "success" ? "green" : "blue";
        }

        getApiKey() {
          return this.apiKey;
        }

        isAPIConnected() {
          return this.isConnected;
        }
      }

      class BaseCanvas extends EventTarget {
        constructor(canvasId) {
          super();
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d", { willReadFrequently: true });
        }
        readImage() {
          return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        }
        writeImage(data) {
          this.ctx.putImageData(data, 0, 0);
        }
      }

      class DrawingCanvas extends BaseCanvas {
        constructor(canvasId) {
          super(canvasId);
          this.isDrawing = false;
          this.ctx.lineWidth = 2;
          this.ctx.lineCap = "round";
          this.ctx.strokeStyle = "#000";
          this.canvas.addEventListener("pointerdown", (e) => this.startDrawing(e));
          this.canvas.addEventListener("pointermove", (e) => this.draw(e));
          this.canvas.addEventListener("pointerup", () => this.stopDrawing());
          this.canvas.addEventListener("pointerout", () => this.completeDrawing());
        }
        startDrawing(e) {
          this.isDrawing = true;
          const rect = this.canvas.getBoundingClientRect();
          this.ctx.beginPath();
          this.ctx.moveTo(e.clientX - rect.left, e.clientY - rect.top);
        }
        draw(e) {
          if (!this.isDrawing) return;
          const rect = this.canvas.getBoundingClientRect();
          this.ctx.lineTo(e.clientX - rect.left, e.clientY - rect.top);
          this.ctx.stroke();
        }
        stopDrawing() {
          this.isDrawing = false;
        }
        completeDrawing() {
          this.dispatchEvent(new CustomEvent("drawingstop"));
        }
        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
      }

      class GenerativeCanvas extends BaseCanvas {
        constructor(canvasId, drawingCanvas) {
          super(canvasId);
          this.drawingCanvas = drawingCanvas;
          this.drawingCanvas.addEventListener("drawingstop", () => this.replicate());
        }
        replicate() {
          const imageData = this.drawingCanvas.readImage();
          this.writeImage(imageData);
        }
      }
      const drawingCanvas = new DrawingCanvas("DrawCanvas");
      const generativeCanvas = new GenerativeCanvas("GenerativeCanvas", drawingCanvas);
      new DrawingCanvas("StylizeCanvas");
      new DrawingCanvas("AnimateCanvas");

      const aiConnection = new AIConnection();
    </script>
  </body>
</html>
