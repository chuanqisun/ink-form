<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL2 Particle System with Stroke Canvas</title>
  </head>
  <body>
    <canvas id="particleCanvas" width="300" height="600" style="border: 4px double #000"></canvas>
    <canvas id="strokeCanvas" width="300" height="600" style="border: 4px double #000"></canvas>
    <br />
    <button id="clearBtn">Clear</button>
    <div>Particles: <span id="count">0</span></div>
    <div>FPS: <span id="fps">0</span></div>

    <script>
      // ============================================================================
      // Performance Monitoring
      // ============================================================================
      class PerformanceMonitor {
        constructor(sampleSize = 10) {
          this.frameTimes = [];
          this.sampleSize = sampleSize;
          this.lastTime = 0;
        }

        update(currentTime) {
          if (this.lastTime > 0) {
            this.frameTimes.push(currentTime - this.lastTime);
            if (this.frameTimes.length > this.sampleSize) this.frameTimes.shift();
          }
          this.lastTime = currentTime;
          return this.getFPS();
        }

        getFPS() {
          if (this.frameTimes.length === 0) return 0;
          const avgDelta = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
          return Math.round(1000 / avgDelta);
        }
      }

      // ============================================================================
      // Stroke Canvas - Handles user drawing input
      // ============================================================================
      class StrokeCanvas {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.isDrawing = false;
          this._configureContext();
        }

        _configureContext() {
          this.ctx.lineWidth = 2;
          this.ctx.lineCap = "round";
          this.ctx.strokeStyle = "#000";
        }

        startDrawing(x, y) {
          this.isDrawing = true;
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
        }

        draw(x, y) {
          if (!this.isDrawing) return;
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
        }

        stopDrawing() {
          this.isDrawing = false;
        }

        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }

        getImageData() {
          return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        }

        get width() {
          return this.canvas.width;
        }
        get height() {
          return this.canvas.height;
        }
      }

      // ============================================================================
      // Particle System - Manages particle simulation and physics
      // ============================================================================
      class ParticleSystem {
        constructor(maxParticles = 100000) {
          this.maxParticles = maxParticles;
          this.particles = [];
          this.config = {
            spawnRadius: 30,
            searchRadius: 50,
            attractionStrength: 0.5,
            randomness: 0.5,
            damping: 0.99,
            wallBounce: 0.8,
          };
        }

        addParticles(count, spawnX, spawnY) {
          const available = this.maxParticles - this.particles.length;
          if (available <= 0) return 0;

          const toAdd = Math.min(count, available);
          const { spawnRadius } = this.config;

          for (let i = 0; i < toAdd; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spawnRadius;

            this.particles.push({
              x: spawnX + Math.cos(angle) * distance,
              y: spawnY + Math.sin(angle) * distance,
              vx: (Math.random() - 0.5) * 2,
              vy: (Math.random() - 0.5) * 2,
              settled: false,
            });
          }

          return toAdd;
        }

        update(strokeImageData, canvasWidth, canvasHeight) {
          const { data: strokeData, width: imgWidth, height: imgHeight } = strokeImageData;

          for (const particle of this.particles) {
            if (particle.settled) continue;

            if (this._checkSettlement(particle, strokeData, imgWidth, imgHeight)) {
              particle.settled = true;
              particle.vx = particle.vy = 0;
              continue;
            }

            this._applyForceField(particle, strokeData, imgWidth, imgHeight);
            this._applyRandomness(particle);
            this._applyDamping(particle);
            this._updatePosition(particle);
            this._handleBoundaries(particle, canvasWidth, canvasHeight);
          }
        }

        _checkSettlement(particle, strokeData, width, height) {
          const px = Math.floor(particle.x);
          const py = Math.floor(particle.y);

          if (px < 0 || px >= width || py < 0 || py >= height) return false;

          const index = (py * width + px) * 4;
          return strokeData[index + 3] > 0; // Check alpha channel
        }

        _applyForceField(particle, strokeData, width, height) {
          const { searchRadius, attractionStrength } = this.config;
          const closest = this._findClosestStrokePixel(particle, strokeData, width, height, searchRadius);

          if (!closest) return;

          const dx = closest.x - particle.x;
          const dy = closest.y - particle.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            const force = attractionStrength / (1 + dist * 0.1);
            particle.vx += (dx / dist) * force;
            particle.vy += (dy / dist) * force;
          }
        }

        _findClosestStrokePixel(particle, strokeData, width, height, searchRadius) {
          const startX = Math.max(0, Math.floor(particle.x - searchRadius));
          const endX = Math.min(width - 1, Math.ceil(particle.x + searchRadius));
          const startY = Math.max(0, Math.floor(particle.y - searchRadius));
          const endY = Math.min(height - 1, Math.ceil(particle.y + searchRadius));

          let closestDist = Infinity;
          let closest = null;

          for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
              const index = (y * width + x) * 4;
              if (strokeData[index + 3] === 0) continue; // No stroke here

              const dx = x - particle.x;
              const dy = y - particle.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              if (dist < closestDist && dist > 0) {
                closestDist = dist;
                closest = { x, y };
              }
            }
          }

          return closest;
        }

        _applyRandomness(particle) {
          const { randomness } = this.config;
          particle.vx += (Math.random() - 0.5) * randomness;
          particle.vy += (Math.random() - 0.5) * randomness;
        }

        _applyDamping(particle) {
          const { damping } = this.config;
          particle.vx *= damping;
          particle.vy *= damping;
        }

        _updatePosition(particle) {
          particle.x += particle.vx;
          particle.y += particle.vy;
        }

        _handleBoundaries(particle, width, height) {
          const { wallBounce } = this.config;

          if (particle.x < 0 || particle.x > width) {
            particle.vx *= -wallBounce;
            particle.x = Math.max(0, Math.min(width, particle.x));
          }

          if (particle.y < 0 || particle.y > height) {
            particle.vy *= -wallBounce;
            particle.y = Math.max(0, Math.min(height, particle.y));
          }
        }

        clear() {
          this.particles = [];
        }

        get count() {
          return this.particles.length;
        }
      }

      // ============================================================================
      // Interactive Canvas - Orchestrates user interaction and rendering
      // ============================================================================
      class InteractiveCanvas {
        constructor(particleCanvasId, strokeCanvasId) {
          this.canvas = document.getElementById(particleCanvasId);
          this.ctx = this.canvas.getContext("2d");
          this.strokeCanvas = new StrokeCanvas(strokeCanvasId);
          this.particleSystem = new ParticleSystem(100000);
          this.perfMonitor = new PerformanceMonitor();

          this.state = {
            isPointerDown: false,
            pointerX: 0,
            pointerY: 0,
            lastAddTime: 0,
            lastFrameTime: 0,
          };

          this.spawnConfig = {
            particlesPerBatch: 10,
            spawnInterval: 10, // milliseconds
          };

          this._initEventListeners();
          this._startAnimationLoop();
        }

        _initEventListeners() {
          this.canvas.addEventListener("pointerdown", (e) => this._onPointerDown(e));
          this.canvas.addEventListener("pointermove", (e) => this._onPointerMove(e));
          this.canvas.addEventListener("pointerup", () => this._onPointerUp());
          this.canvas.addEventListener("pointerout", () => this._onPointerUp());
          document.getElementById("clearBtn").addEventListener("click", () => this.clear());
        }

        _onPointerDown(e) {
          this.state.isPointerDown = true;
          this._updatePointerPosition(e);
          this.strokeCanvas.startDrawing(this.state.pointerX, this.state.pointerY);
        }

        _onPointerMove(e) {
          this._updatePointerPosition(e);
          if (this.state.isPointerDown) {
            this.strokeCanvas.draw(this.state.pointerX, this.state.pointerY);
          }
        }

        _onPointerUp() {
          this.state.isPointerDown = false;
          this.strokeCanvas.stopDrawing();
        }

        _updatePointerPosition(e) {
          const rect = this.canvas.getBoundingClientRect();
          this.state.pointerX = e.clientX - rect.left;
          this.state.pointerY = e.clientY - rect.top;
        }

        _spawnParticles(currentTime) {
          if (!this.state.isPointerDown) return;

          const { lastAddTime } = this.state;
          const { particlesPerBatch, spawnInterval } = this.spawnConfig;

          if (currentTime - lastAddTime > spawnInterval) {
            this.particleSystem.addParticles(particlesPerBatch, this.state.pointerX, this.state.pointerY);
            this.state.lastAddTime = currentTime;
            this._updateParticleCount();
          }
        }

        _updateParticleCount() {
          document.getElementById("count").textContent = this.particleSystem.count;
        }

        _updateFPS(fps) {
          document.getElementById("fps").textContent = fps;
        }

        _render() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.fillStyle = "black";

          for (const particle of this.particleSystem.particles) {
            this.ctx.fillRect(particle.x, particle.y, 1, 1);
          }
        }

        _startAnimationLoop() {
          const animate = (currentTime) => {
            const fps = this.perfMonitor.update(currentTime);
            this._updateFPS(fps);

            this._spawnParticles(currentTime);

            const strokeImageData = this.strokeCanvas.getImageData();
            this.particleSystem.update(strokeImageData, this.canvas.width, this.canvas.height);

            this._render();

            requestAnimationFrame(animate);
          };

          requestAnimationFrame(animate);
        }

        clear() {
          this.particleSystem.clear();
          this._updateParticleCount();
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.strokeCanvas.clear();
        }
      }

      // ============================================================================
      // Initialize Application
      // ============================================================================
      const app = new InteractiveCanvas("particleCanvas", "strokeCanvas");
    </script>
  </body>
</html>
