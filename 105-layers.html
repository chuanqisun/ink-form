<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL2 Particle System with Stroke Canvas</title>
  </head>
  <body>
    <canvas id="particleCanvas" width="300" height="600" style="border: 4px double #000"></canvas>
    <canvas id="strokeCanvas" width="300" height="600" style="border: 4px double #000; cursor: crosshair"></canvas>
    <br />
    <button commandfor="connection-dialog" command="show-modal">Setup</button>
    <button id="clearParticlesBtn">Clear Particles</button>
    <button id="clearStrokeBtn">Clear Stroke</button>
    <button id="renderBtn">Render</button>
    <div>Particles: <span id="count">0</span></div>
    <div>FPS: <span id="fps">0</span></div>
    <div>Status: <span id="status">Idle</span></div>

    <dialog class="connection-form" id="connection-dialog">
      <div class="connections-dialog-body">
        <form method="dialog" id="ai-connection-form">
          <h2>Google AI Studio Connection</h2>
          <label for="api-key-input">API Key:</label>
          <input type="password" id="api-key-input" placeholder="Enter your Google AI Studio API key" />
          <button type="button" id="connect-btn">Connect</button>
          <button type="button" id="disconnect-btn" style="display: none">Disconnect</button>
          <button type="submit">Close</button>
          <div id="connection-status"></div>
        </form>
      </div>
    </dialog>

    <script>
      // ============================================================================
      // Performance Monitoring
      // ============================================================================
      class PerformanceMonitor {
        constructor(sampleSize = 10) {
          this.frameTimes = [];
          this.sampleSize = sampleSize;
          this.lastTime = 0;
        }

        update(currentTime) {
          if (this.lastTime > 0) {
            this.frameTimes.push(currentTime - this.lastTime);
            if (this.frameTimes.length > this.sampleSize) this.frameTimes.shift();
          }
          this.lastTime = currentTime;
          return this.getFPS();
        }

        getFPS() {
          if (this.frameTimes.length === 0) return 0;
          const avgDelta = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
          return Math.round(1000 / avgDelta);
        }
      }

      // ============================================================================
      // AI Connection - Google AI Studio API Integration
      // ============================================================================
      class AIConnection {
        constructor() {
          this.apiKey = null;
          this.isConnected = false;
          this.initEventListeners();
          this.loadApiKey();
        }

        initEventListeners() {
          const connectBtn = document.getElementById("connect-btn");
          const disconnectBtn = document.getElementById("disconnect-btn");
          const apiKeyInput = document.getElementById("api-key-input");

          connectBtn.addEventListener("click", () => this.connect());
          disconnectBtn.addEventListener("click", () => this.disconnect());

          // Allow Enter key to connect
          apiKeyInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              this.connect();
            }
          });
        }

        loadApiKey() {
          const stored = localStorage.getItem("google_ai_api_key");
          if (stored) {
            this.apiKey = stored;
            this.setConnected(true);
          }
        }

        connect() {
          const apiKeyInput = document.getElementById("api-key-input");
          const apiKey = apiKeyInput.value.trim();

          if (!apiKey) {
            this.updateStatus("Please enter an API key", "error");
            return;
          }

          // Store the API key
          this.apiKey = apiKey;
          localStorage.setItem("google_ai_api_key", apiKey);
          this.setConnected(true);
          this.updateStatus("Connected successfully!", "success");
        }

        disconnect() {
          this.apiKey = null;
          localStorage.removeItem("google_ai_api_key");
          this.setConnected(false);
          document.getElementById("api-key-input").value = "";
          this.updateStatus("Disconnected", "info");
        }

        setConnected(connected) {
          this.isConnected = connected;
          const connectBtn = document.getElementById("connect-btn");
          const disconnectBtn = document.getElementById("disconnect-btn");
          const apiKeyInput = document.getElementById("api-key-input");

          if (connected) {
            connectBtn.style.display = "none";
            disconnectBtn.style.display = "inline-block";
            apiKeyInput.disabled = true;
            apiKeyInput.value = this.apiKey;
          } else {
            connectBtn.style.display = "inline-block";
            disconnectBtn.style.display = "none";
            apiKeyInput.disabled = false;
            apiKeyInput.value = "";
          }
        }

        updateStatus(message, type = "info") {
          const statusDiv = document.getElementById("connection-status");
          statusDiv.textContent = message;
          statusDiv.style.color = type === "error" ? "red" : type === "success" ? "green" : "blue";
        }

        getApiKey() {
          return this.apiKey;
        }

        isAPIConnected() {
          return this.isConnected;
        }
      }

      // ============================================================================
      // Image Processor - Converts images to black and white guide strokes
      // ============================================================================
      class ImageProcessor {
        /**
         * Convert any image to black and white guide strokes
         * @param {Blob|File} blob - Image blob to process
         * @param {number} maxWidth - Maximum width to scale to
         * @param {number} maxHeight - Maximum height to scale to
         * @returns {Promise<Object>} Object containing { imageData, scaledWidth, scaledHeight, offsetX, offsetY }
         */
        static async processImage(blob, maxWidth, maxHeight) {
          return new Promise((resolve, reject) => {
            const url = URL.createObjectURL(blob);
            const img = new Image();

            img.onload = () => {
              try {
                const { imageData, scaledWidth, scaledHeight, offsetX, offsetY } = ImageProcessor.convertToBlackAndWhite(img, maxWidth, maxHeight);

                URL.revokeObjectURL(url);
                resolve({ imageData, scaledWidth, scaledHeight, offsetX, offsetY });
              } catch (error) {
                URL.revokeObjectURL(url);
                reject(error);
              }
            };

            img.onerror = () => {
              URL.revokeObjectURL(url);
              reject(new Error("Failed to load image"));
            };

            img.src = url;
          });
        }

        /**
         * Calculate optimal threshold using Otsu's method
         * @param {Uint8Array} grayscaleData - Grayscale pixel values
         * @returns {number} Optimal threshold value (0-255)
         */
        static calculateOtsuThreshold(grayscaleData) {
          // Build histogram
          const histogram = new Array(256).fill(0);
          for (let i = 0; i < grayscaleData.length; i++) {
            histogram[grayscaleData[i]]++;
          }

          // Total number of pixels
          const total = grayscaleData.length;

          let sum = 0;
          for (let i = 0; i < 256; i++) {
            sum += i * histogram[i];
          }

          let sumB = 0;
          let wB = 0;
          let wF = 0;
          let maxVariance = 0;
          let threshold = 0;

          for (let i = 0; i < 256; i++) {
            wB += histogram[i];
            if (wB === 0) continue;

            wF = total - wB;
            if (wF === 0) break;

            sumB += i * histogram[i];

            const mB = sumB / wB;
            const mF = (sum - sumB) / wF;

            const variance = wB * wF * (mB - mF) * (mB - mF);

            if (variance > maxVariance) {
              maxVariance = variance;
              threshold = i;
            }
          }

          return threshold;
        }

        /**
         * Convert an image element to pure black and white
         * @param {HTMLImageElement} img - Image element to convert
         * @param {number} maxWidth - Maximum width to scale to
         * @param {number} maxHeight - Maximum height to scale to
         * @returns {Object} Object containing imageData and scaling information
         */
        static convertToBlackAndWhite(img, maxWidth, maxHeight) {
          // Calculate scaling to fit container while maintaining aspect ratio
          const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
          const scaledWidth = img.width * scale;
          const scaledHeight = img.height * scale;
          const offsetX = (maxWidth - scaledWidth) / 2;
          const offsetY = (maxHeight - scaledHeight) / 2;

          // Create a canvas sized to match the final display dimensions (including white background)
          const displayCanvas = document.createElement("canvas");
          displayCanvas.width = maxWidth;
          displayCanvas.height = maxHeight;
          const displayCtx = displayCanvas.getContext("2d");

          // Paint entire canvas white
          displayCtx.fillStyle = "#FFFFFF";
          displayCtx.fillRect(0, 0, maxWidth, maxHeight);

          // Draw the image on the white background with alpha blending
          // This allows the image to blend naturally with the white background
          displayCtx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);

          // Get the blended image data from the display canvas
          const blendedImageData = displayCtx.getImageData(0, 0, maxWidth, maxHeight);
          const data = blendedImageData.data;

          // First pass: Convert blended image to grayscale using luminosity method
          const grayscale = new Uint8Array(maxWidth * maxHeight);
          for (let i = 0; i < data.length; i += 4) {
            const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
            grayscale[i / 4] = gray;
          }

          // Calculate optimal threshold using Otsu's method
          const threshold = ImageProcessor.calculateOtsuThreshold(grayscale);

          // Second pass: Apply threshold to create pure black and white
          for (let i = 0; i < grayscale.length; i++) {
            const bw = grayscale[i] > threshold ? 255 : 0;
            data[i * 4] = bw;
            data[i * 4 + 1] = bw;
            data[i * 4 + 2] = bw;
            data[i * 4 + 3] = 255; // Ensure alpha is fully opaque
          }

          return {
            imageData: blendedImageData,
            scaledWidth: maxWidth,
            scaledHeight: maxHeight,
            offsetX: 0,
            offsetY: 0,
          };
        }

        /**
         * Apply guide strokes to a canvas context
         * @param {CanvasRenderingContext2D} ctx - Canvas context to draw to
         * @param {ImageData} imageData - Processed image data (grayscale)
         * @param {number} srcWidth - Source image width
         * @param {number} srcHeight - Source image height
         * @param {number} destX - Destination X coordinate on canvas
         * @param {number} destY - Destination Y coordinate on canvas
         * @param {number} destWidth - Destination width on canvas
         * @param {number} destHeight - Destination height on canvas
         */
        static applyGuidesToCanvas(ctx, imageData, srcWidth, srcHeight, destX, destY, destWidth, destHeight) {
          // Create temporary canvas from processed imageData
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = srcWidth;
          tempCanvas.height = srcHeight;
          const tempCtx = tempCanvas.getContext("2d");
          tempCtx.putImageData(imageData, 0, 0);

          // Draw to destination canvas with scaling
          ctx.drawImage(tempCanvas, 0, 0, srcWidth, srcHeight, destX, destY, destWidth, destHeight);
        }
      }

      // ============================================================================
      // Stroke Canvas - Handles user drawing input
      // ============================================================================
      class StrokeCanvas {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.isDrawing = false;
          this.lastHash = null;
          this.currentStrokeColor = "#000"; // Default color
          this.listeners = {
            strokeUpdated: [],
            imageLoaded: [],
          };
          this._configureContext();
          this._initEventListeners();
        }

        // Event system for decoupling
        on(event, callback) {
          if (this.listeners[event]) {
            this.listeners[event].push(callback);
          }
        }

        emit(event, data) {
          if (this.listeners[event]) {
            this.listeners[event].forEach((callback) => callback(data));
          }
        }

        _configureContext() {
          this.ctx.lineWidth = 2;
          this.ctx.lineCap = "round";
          this.ctx.strokeStyle = this.currentStrokeColor;
        }

        _initEventListeners() {
          this.canvas.addEventListener("pointerdown", (e) => this._onPointerDown(e));
          this.canvas.addEventListener("pointermove", (e) => this._onPointerMove(e));
          this.canvas.addEventListener("pointerup", () => this._onPointerUp());
          this.canvas.addEventListener("pointerout", () => this._onPointerUp());
        }

        _onPointerDown(e) {
          this.isDrawing = true;
          // Set color to red for direct drawing on stroke canvas
          this.setStrokeColor("#ff0000");
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
        }

        _onPointerMove(e) {
          if (!this.isDrawing) return;
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
        }

        _onPointerUp() {
          this.isDrawing = false;
        }

        setStrokeColor(color) {
          this.currentStrokeColor = color;
          this.ctx.strokeStyle = color;
        }

        startDrawing(x, y, color = "#000") {
          this.isDrawing = true;
          this.setStrokeColor(color);
          this.ctx.beginPath();
          this.ctx.moveTo(x, y);
        }

        draw(x, y) {
          if (!this.isDrawing) return;
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
        }

        stopDrawing() {
          this.isDrawing = false;
        }

        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.lastHash = null;
        }

        getImageData() {
          return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        }

        /**
         * Set image from a Blob or File as guide strokes
         * Automatically converts colored images to grayscale for use as force field
         */
        async setImageFromBlob(blob) {
          try {
            const { imageData, scaledWidth, scaledHeight, offsetX, offsetY } = await ImageProcessor.processImage(blob, this.canvas.width, this.canvas.height);

            // Clear canvas first
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // Apply processed guide strokes to canvas
            ImageProcessor.applyGuidesToCanvas(this.ctx, imageData, imageData.width, imageData.height, offsetX, offsetY, scaledWidth, scaledHeight);

            // Emit event for new image loaded
            this.emit("imageLoaded", { imageData, scaledWidth, scaledHeight, offsetX, offsetY });
          } catch (error) {
            console.error("Failed to process image:", error);
          }
        }

        /**
         * Check if the stroke canvas content has changed since last check
         * @returns {boolean} true if content has changed, false otherwise
         */
        hasChanged() {
          const imageData = this.getImageData();
          const currentHash = this._computeHash(imageData.data);
          const hasChanged = this.lastHash === null || this.lastHash !== currentHash;
          this.lastHash = currentHash;
          return hasChanged;
        }

        /**
         * Compute a simple hash of the image data for change detection
         * @private
         */
        _computeHash(data) {
          let hash = 0;
          // Sample every 100th pixel for performance
          for (let i = 0; i < data.length; i += 400) {
            hash = (hash << 5) - hash + data[i];
            hash = hash & hash; // Convert to 32bit integer
          }
          return hash.toString();
        }

        /**
         * Convert all strokes on the canvas to black
         */
        convertToBlack() {
          const imageData = this.getImageData();
          const data = imageData.data;

          // Convert all non-transparent pixels to black
          for (let i = 0; i < data.length; i += 4) {
            if (data[i + 3] > 0) {
              // If pixel has any opacity, make it black
              data[i] = 0; // R
              data[i + 1] = 0; // G
              data[i + 2] = 0; // B
              // Keep alpha channel as is
            }
          }

          this.ctx.putImageData(imageData, 0, 0);
          this.setStrokeColor("#000"); // Reset stroke color for future drawing
          this.lastHash = null; // Reset hash to force change detection
        }

        get width() {
          return this.canvas.width;
        }
        get height() {
          return this.canvas.height;
        }
      }

      // ============================================================================
      // Particle System - Manages particle simulation and physics
      // ============================================================================
      class ParticleSystem {
        constructor(maxParticles = 100000) {
          this.maxParticles = maxParticles;
          this.particles = [];
          this.removingParticles = []; // Particles being animated away
          this.config = {
            spawnRadius: 30,
            searchRadius: 50,
            attractionStrength: 0.5,
            randomness: 0.5,
            damping: 0.99,
            wallBounce: 0.8,
            // Unified particle density configuration
            particlesPerPixel: 2.5, // Target density for even distribution
          };

          // Render phase state machine - simplified
          this.renderPhase = {
            active: false,
            duration: 90, // Total frames for transition
            frameCount: 0,
          };
        }

        addParticles(count, spawnX, spawnY) {
          const available = this.maxParticles - this.particles.length;
          if (available <= 0) return 0;

          const toAdd = Math.min(count, available);
          const { spawnRadius } = this.config;

          for (let i = 0; i < toAdd; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spawnRadius;

            this.particles.push({
              x: spawnX + Math.cos(angle) * distance,
              y: spawnY + Math.sin(angle) * distance,
              vx: (Math.random() - 0.5) * 2,
              vy: (Math.random() - 0.5) * 2,
              settled: false,
            });
          }

          return toAdd;
        }

        update(strokeImageData, canvasWidth, canvasHeight) {
          const { data: strokeData, width: imgWidth, height: imgHeight } = strokeImageData;

          // Update render phase
          if (this.renderPhase.active) {
            this.renderPhase.frameCount++;
            if (this.renderPhase.frameCount >= this.renderPhase.duration) {
              this.renderPhase.active = false;
              this.renderPhase.frameCount = 0;
            }
          }

          for (const particle of this.particles) {
            // Handle transitioning particles (moving to target)
            if (particle.isTransitioning && particle.targetX !== null) {
              this._updateTransition(particle);
              continue;
            }

            // Handle normal particles (following stroke)
            if (particle.settled) continue;

            if (this._checkSettlement(particle, strokeData, imgWidth, imgHeight)) {
              particle.settled = true;
              particle.vx = particle.vy = 0;
              continue;
            }

            this._applyForceField(particle, strokeData, imgWidth, imgHeight);
            this._applyRandomness(particle);
            this._applyDamping(particle);
            this._updatePosition(particle);
            this._handleBoundaries(particle, canvasWidth, canvasHeight);
          }

          // Update particles being removed
          this._updateRemovingParticles(canvasWidth, canvasHeight);
        }

        /**
         * Update particle that is transitioning to its target position
         * Uses smooth interpolation
         * @private
         */
        _updateTransition(particle) {
          // Simple interpolation towards target
          particle.x = particle.x + (particle.targetX - particle.x) * 0.1;
          particle.y = particle.y + (particle.targetY - particle.y) * 0.1;

          // Check if reached target
          const dx = particle.targetX - particle.x;
          const dy = particle.targetY - particle.y;
          const distSq = dx * dx + dy * dy;

          if (distSq < 1 || !this.renderPhase.active) {
            particle.x = particle.targetX;
            particle.y = particle.targetY;
            particle.vx = 0;
            particle.vy = 0;
            particle.settled = true;
            particle.isTransitioning = false;
          }
        }

        _updateRemovingParticles(canvasWidth, canvasHeight) {
          for (let i = this.removingParticles.length - 1; i >= 0; i--) {
            const particle = this.removingParticles[i];

            // Accelerate away from center with increasing speed
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const dx = particle.x - centerX;
            const dy = particle.y - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0) {
              const retreatForce = 0.3;
              particle.vx += (dx / dist) * retreatForce;
              particle.vy += (dy / dist) * retreatForce;
            }

            // Apply velocity
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Decrease lifetime
            particle.lifetime -= 1;

            // Remove when off-screen or lifetime expires
            if (particle.lifetime <= 0 || particle.x < -50 || particle.x > canvasWidth + 50 || particle.y < -50 || particle.y > canvasHeight + 50) {
              this.removingParticles.splice(i, 1);
            }
          }
        }

        _checkSettlement(particle, strokeData, width, height) {
          const px = Math.floor(particle.x);
          const py = Math.floor(particle.y);

          if (px < 0 || px >= width || py < 0 || py >= height) return false;

          const index = (py * width + px) * 4;
          return strokeData[index + 3] > 0; // Check alpha channel
        }

        _applyForceField(particle, strokeData, imgWidth, imgHeight) {
          const { searchRadius, attractionStrength } = this.config;
          const closest = this._findClosestStrokePixel(particle, strokeData, imgWidth, imgHeight, searchRadius);

          if (!closest) return;

          const dx = closest.x - particle.x;
          const dy = closest.y - particle.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            const force = attractionStrength / (1 + dist * 0.1);
            particle.vx += (dx / dist) * force;
            particle.vy += (dy / dist) * force;
          }
        }

        _findClosestStrokePixel(particle, strokeData, width, height, searchRadius) {
          const startX = Math.max(0, Math.floor(particle.x - searchRadius));
          const endX = Math.min(width - 1, Math.ceil(particle.x + searchRadius));
          const startY = Math.max(0, Math.floor(particle.y - searchRadius));
          const endY = Math.min(height - 1, Math.ceil(particle.y + searchRadius));

          let closestDist = Infinity;
          let closest = null;

          for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
              const index = (y * width + x) * 4;
              if (strokeData[index + 3] === 0) continue; // No stroke here

              const dx = x - particle.x;
              const dy = y - particle.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              if (dist < closestDist && dist > 0) {
                closestDist = dist;
                closest = { x, y };
              }
            }
          }

          return closest;
        }

        _applyRandomness(particle) {
          const { randomness } = this.config;
          particle.vx += (Math.random() - 0.5) * randomness;
          particle.vy += (Math.random() - 0.5) * randomness;
        }

        _applyDamping(particle) {
          const { damping } = this.config;
          particle.vx *= damping;
          particle.vy *= damping;
        }

        _updatePosition(particle) {
          particle.x += particle.vx;
          particle.y += particle.vy;
        }

        _handleBoundaries(particle, width, height) {
          const { wallBounce } = this.config;

          if (particle.x < 0 || particle.x > width) {
            particle.vx *= -wallBounce;
            particle.x = Math.max(0, Math.min(width, particle.x));
          }

          if (particle.y < 0 || particle.y > height) {
            particle.vy *= -wallBounce;
            particle.y = Math.max(0, Math.min(height, particle.y));
          }
        }

        clear() {
          this.particles = [];
          this.removingParticles = [];
        }

        get count() {
          return this.particles.length;
        }

        /**
         * Calculate the number of particles that should settle on the current stroke
         * Uses the unified particlesPerPixel density for consistency
         * @private
         */
        _calculateTargetParticleCount(strokeImageData) {
          const { data: strokeData } = strokeImageData;
          let pixelCount = 0;

          // Count all stroke pixels
          for (let i = 3; i < strokeData.length; i += 4) {
            if (strokeData[i] > 128) {
              pixelCount++;
            }
          }

          // Use unified particle density
          return Math.floor(pixelCount * this.config.particlesPerPixel);
        }

        /**
         * Mark particles for removal with retreat animation
         * Moves them away from their position and disappears
         * @private
         */
        _markParticlesForRemoval(count) {
          const toRemove = Math.min(count, this.particles.length);

          for (let i = 0; i < toRemove; i++) {
            const particle = this.particles[i];
            this.removingParticles.push({
              x: particle.x,
              y: particle.y,
              vx: (Math.random() - 0.5) * 2,
              vy: (Math.random() - 0.5) * 2,
              lifetime: 60, // 60 frames to disappear
            });
          }

          // Remove from active particles
          this.particles.splice(0, toRemove);
        }

        /**
         * Spawn new particles from existing particle positions
         * @private
         */
        _spawnFromExisting(count) {
          if (this.particles.length === 0) return;

          const available = this.maxParticles - this.particles.length;
          const toSpawn = Math.min(count, available);

          for (let i = 0; i < toSpawn; i++) {
            // Pick a random existing particle to spawn from
            const source = this.particles[Math.floor(Math.random() * this.particles.length)];

            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * this.config.spawnRadius;

            this.particles.push({
              x: source.x + Math.cos(angle) * distance,
              y: source.y + Math.sin(angle) * distance,
              vx: (Math.random() - 0.5) * 2,
              vy: (Math.random() - 0.5) * 2,
              settled: false,
            });
          }
        }

        /**
         * Assign target positions to all particles based on stroke pixels
         * Distributes particles evenly across stroke pixels
         * @private
         */
        _assignTargetPositions(strokeImageData) {
          const { data: strokeData, width, height } = strokeImageData;

          // Collect all stroke pixel positions
          const strokePixels = [];
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const index = (y * width + x) * 4;
              if (strokeData[index + 3] > 128) {
                strokePixels.push({ x, y });
              }
            }
          }

          if (strokePixels.length === 0) return;

          // Shuffle stroke pixels for better distribution
          for (let i = strokePixels.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [strokePixels[i], strokePixels[j]] = [strokePixels[j], strokePixels[i]];
          }

          // Assign target positions to particles
          // Use modulo to cycle through stroke pixels if there are more particles than pixels
          for (let i = 0; i < this.particles.length; i++) {
            const targetPixel = strokePixels[i % strokePixels.length];
            const particle = this.particles[i];

            // Add small random offset for natural look
            particle.targetX = targetPixel.x + (Math.random() - 0.5) * 2;
            particle.targetY = targetPixel.y + (Math.random() - 0.5) * 2;
            particle.isTransitioning = true;
            particle.settled = false;

            // Give random initial velocity for visual interest
            particle.vx = (Math.random() - 0.5) * 4;
            particle.vy = (Math.random() - 0.5) * 4;
          }
        }

        /**
         * Start the render phase - assigns targets and begins transition
         * @private
         */
        _startRenderPhase(strokeImageData) {
          this._assignTargetPositions(strokeImageData);
          this.renderPhase.active = true;
          this.renderPhase.frameCount = 0;
        }
      }

      // ============================================================================
      // Interactive Canvas - Orchestrates user interaction and rendering
      // ============================================================================
      class InteractiveCanvas {
        constructor(particleCanvasId, strokeCanvasId) {
          this.canvas = document.getElementById(particleCanvasId);
          this.ctx = this.canvas.getContext("2d");
          this.strokeCanvas = new StrokeCanvas(strokeCanvasId);
          this.particleSystem = new ParticleSystem(100000);
          this.perfMonitor = new PerformanceMonitor();

          this.state = {
            isPointerDown: false,
            pointerX: 0,
            pointerY: 0,
            prevPointerX: 0,
            prevPointerY: 0,
            lastSpawnX: 0,
            lastSpawnY: 0,
            accumulatedDistance: 0,
            lastMoveTime: 0,
            velocity: 0, // Current cursor velocity in pixels per frame
          };

          this.spawnConfig = {
            spawnSpacing: 1, // Pixels between spawn points for even distribution
            pauseThreshold: 100, // Milliseconds of no movement before stopping spawns
            maxVelocity: 50, // Maximum velocity cap for particle count scaling
          };

          this._initEventListeners();
          this._startAnimationLoop();
          this.setupStrokeCanvasListeners();
        }

        _initEventListeners() {
          this.canvas.addEventListener("pointerdown", (e) => this._onPointerDown(e));
          this.canvas.addEventListener("pointermove", (e) => this._onPointerMove(e));
          this.canvas.addEventListener("pointerup", () => this._onPointerUp());
          this.canvas.addEventListener("pointerout", () => this._onPointerUp());
          document.getElementById("clearParticlesBtn").addEventListener("click", () => this.clearParticles());
          document.getElementById("clearStrokeBtn").addEventListener("click", () => this.clearStroke());
          document.getElementById("renderBtn").addEventListener("click", () => this.render());

          // Handle image paste events
          document.addEventListener("paste", (e) => this.handlePaste(e));
        }

        handlePaste(e) {
          const items = e.clipboardData?.items;
          if (!items) return;

          for (const item of items) {
            if (item.type.startsWith("image/")) {
              e.preventDefault();
              const blob = item.getAsFile();
              if (blob) {
                this.strokeCanvas.setImageFromBlob(blob);
              }
              break;
            }
          }
        }

        /**
         * Setup listeners for stroke canvas events (decoupled communication)
         */
        setupStrokeCanvasListeners() {
          // Listen for new image loaded events
          this.strokeCanvas.on("imageLoaded", () => {
            this.handleNewGuideImage();
          });

          // Listen for stroke updates to invalidate cache
          this.strokeCanvas.on("strokeUpdated", ({ type }) => {
            if (type === "clear") {
              this.particleSystem.clear();
              this._updateParticleCount();
            }
          });
        }

        /**
         * Handle new guide image by resetting all particles to diffusion phase
         * This naturally triggers phases 1 and 2 to re-run
         */
        handleNewGuideImage() {
          const now = performance.now();
          const particleCount = this.particleSystem.count;

          // Reset all existing particles to start fresh diffusion
          this.particleSystem.particles.forEach((particle) => {
            particle.birthTime = now;
            particle.phase = "diffusion";

            // Give particles new random initial velocities for diffusion
            const speed = 3 + Math.random() * 2;
            const angle = Math.random() * Math.PI * 2;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;
          });

          console.log(`New guide image loaded - ${particleCount} particles reset to diffusion phase`);
        }

        _onPointerDown(e) {
          this.state.isPointerDown = true;
          this._updatePointerPosition(e);
          this.strokeCanvas.startDrawing(this.state.pointerX, this.state.pointerY);
          // Initialize spawn tracking at pointer down
          this.state.lastSpawnX = this.state.pointerX;
          this.state.lastSpawnY = this.state.pointerY;
          this.state.prevPointerX = this.state.pointerX;
          this.state.prevPointerY = this.state.pointerY;
          this.state.accumulatedDistance = 0;
          this.state.lastMoveTime = performance.now();
        }

        _onPointerMove(e) {
          this._updatePointerPosition(e);
          if (this.state.isPointerDown) {
            this.strokeCanvas.draw(this.state.pointerX, this.state.pointerY);
          }
        }

        _onPointerUp() {
          this.state.isPointerDown = false;
          this.strokeCanvas.stopDrawing();
        }

        _updatePointerPosition(e) {
          const rect = this.canvas.getBoundingClientRect();
          const newX = e.clientX - rect.left;
          const newY = e.clientY - rect.top;

          // Calculate instantaneous velocity
          if (this.state.isPointerDown) {
            const dx = newX - this.state.pointerX;
            const dy = newY - this.state.pointerY;
            this.state.velocity = Math.sqrt(dx * dx + dy * dy);
            this.state.lastMoveTime = performance.now();
          }

          this.state.prevPointerX = this.state.pointerX;
          this.state.prevPointerY = this.state.pointerY;
          this.state.pointerX = newX;
          this.state.pointerY = newY;
        }

        _spawnParticles(currentTime) {
          if (!this.state.isPointerDown) return;

          // Check if user has stopped moving (pause detection)
          const timeSinceLastMove = currentTime - this.state.lastMoveTime;
          if (timeSinceLastMove > this.spawnConfig.pauseThreshold) {
            // User has paused, don't spawn more particles
            return;
          }

          // Calculate distance traveled since last spawn
          const dx = this.state.pointerX - this.state.lastSpawnX;
          const dy = this.state.pointerY - this.state.lastSpawnY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < this.spawnConfig.spawnSpacing) {
            // Not enough distance traveled yet
            return;
          }

          // Get the interpolated path points between previous and current cursor position
          const pathPoints = this._getInterpolatedPath(
            this.state.lastSpawnX,
            this.state.lastSpawnY,
            this.state.pointerX,
            this.state.pointerY,
            this.spawnConfig.spawnSpacing
          );

          // Calculate particles per spawn point using unified density
          const particlesPerPixel = this.particleSystem.config.particlesPerPixel;
          const particlesPerSpawn = Math.ceil(particlesPerPixel * this.spawnConfig.spawnSpacing);

          // Spawn particles at each interpolated point
          for (const point of pathPoints) {
            this.particleSystem.addParticles(particlesPerSpawn, point.x, point.y);
          }

          if (pathPoints.length > 0) {
            this._updateParticleCount();
            // Update spawn position to current cursor position
            this.state.lastSpawnX = this.state.pointerX;
            this.state.lastSpawnY = this.state.pointerY;
          }
        }

        /**
         * Generate interpolated points along the path from start to end
         * Using a line-drawing-like algorithm to ensure even spacing and no gaps
         * @private
         */
        _getInterpolatedPath(startX, startY, endX, endY, spacing) {
          const points = [];
          const dx = endX - startX;
          const dy = endY - startY;
          const totalDistance = Math.sqrt(dx * dx + dy * dy);

          if (totalDistance < spacing) {
            // Distance is too small, don't spawn yet
            return points;
          }

          // Calculate number of spawn points needed to cover the distance
          const numPoints = Math.floor(totalDistance / spacing);

          for (let i = 1; i <= numPoints; i++) {
            const t = i / (numPoints + 1);
            points.push({
              x: startX + dx * t,
              y: startY + dy * t,
            });
          }

          return points;
        }

        _updateParticleCount() {
          document.getElementById("count").textContent = this.particleSystem.count;
        }

        _updateFPS(fps) {
          document.getElementById("fps").textContent = fps;
        }

        _updateStatus() {
          const statusEl = document.getElementById("status");
          if (!this.particleSystem.renderPhase.active) {
            statusEl.textContent = "Idle";
            return;
          }

          const frameCount = this.particleSystem.renderPhase.frameCount;
          const duration = this.particleSystem.renderPhase.duration;
          statusEl.textContent = `Transitioning (${frameCount}/${duration})`;
        }

        _render() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.fillStyle = "black";

          for (const particle of this.particleSystem.particles) {
            this.ctx.fillRect(particle.x, particle.y, 1, 1);
          }

          // Render particles being removed
          for (const particle of this.particleSystem.removingParticles) {
            this.ctx.fillRect(particle.x, particle.y, 1, 1);
          }
        }

        _startAnimationLoop() {
          const animate = (currentTime) => {
            const fps = this.perfMonitor.update(currentTime);
            this._updateFPS(fps);
            this._updateStatus();

            this._spawnParticles(currentTime);

            const strokeImageData = this.strokeCanvas.getImageData();
            this.particleSystem.update(strokeImageData, this.canvas.width, this.canvas.height);

            this._render();

            requestAnimationFrame(animate);
          };

          requestAnimationFrame(animate);
        }

        clear() {
          this.particleSystem.clear();
          this._updateParticleCount();
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.strokeCanvas.clear();
        }

        clearParticles() {
          this.particleSystem.clear();
          this._updateParticleCount();
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }

        clearStroke() {
          this.strokeCanvas.clear();
        }

        /**
         * Render method: called when user clicks render button
         * Calculates needed particles based on stroke content
         * - Spawns new particles from existing positions if more needed
         * - Animates removal of particles if fewer needed
         * - Initiates relaxation and re-attraction cycle to reposition particles
         */
        render() {
          const strokeImageData = this.strokeCanvas.getImageData();
          const targetCount = this.particleSystem._calculateTargetParticleCount(strokeImageData);
          const currentCount = this.particleSystem.count;

          if (targetCount > currentCount) {
            // Need to spawn new particles
            const particlesToSpawn = targetCount - currentCount;
            this.particleSystem._spawnFromExisting(particlesToSpawn);
            this._updateParticleCount();
          } else if (targetCount < currentCount) {
            // Need to remove particles
            const particlesToRemove = currentCount - targetCount;
            this.particleSystem._markParticlesForRemoval(particlesToRemove);
            this._updateParticleCount();
          }

          // Start render phase cycle to reposition particles
          this.particleSystem._startRenderPhase(strokeImageData);

          // Change all strokes to black after attracting particles
          this.strokeCanvas.convertToBlack();
        }
      }

      // ============================================================================
      // Initialize Application
      // ============================================================================
      const aiConnection = new AIConnection();
      const app = new InteractiveCanvas("particleCanvas", "strokeCanvas");
    </script>
  </body>
</html>
